<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kutear.github.io</id>
    <title>Gridea</title>
    <updated>2019-11-07T08:57:38.216Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kutear.github.io"/>
    <link rel="self" href="https://kutear.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://kutear.github.io/images/avatar.png</logo>
    <icon>https://kutear.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[对Window/WindowManager和WindowManagerSystem的理解]]></title>
        <id>https://kutear.github.io/post/dui-windowithwindowmanager-he-windowmanagersystem-de-li-jie</id>
        <link href="https://kutear.github.io/post/dui-windowithwindowmanager-he-windowmanagersystem-de-li-jie">
        </link>
        <updated>2019-11-07T08:31:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="windowsmanager">WindowsManager</h1>
<h2 id="window的type">Window的type</h2>
<blockquote>
<p>The general type of window.  There are three main classes of<br>
window types:</p>
</blockquote>
  <ul>
  <li> <strong>Application windows</strong> (ranging from
  {@link #FIRST_APPLICATION_WINDOW} to
  {@link #LAST_APPLICATION_WINDOW}) are normal top-level application
  windows.  For these types of windows, the {@link #token} must be
  set to the token of the activity they are a part of (this will
  normally be done for you if {@link #token} is null).
  <li> <strong>Sub-windows</strong> (ranging from
  {@link #FIRST_SUB_WINDOW} to
  {@link #LAST_SUB_WINDOW}) are associated with another top-level
  window.  For these types of windows, the {@link #token} must be
  the token of the window it is attached to.
  <li> <strong>System windows</strong> (ranging from
  {@link #FIRST_SYSTEM_WINDOW} to
  {@link #LAST_SYSTEM_WINDOW}) are special types of windows for
  use by the system for specific purposes.  They should not normally
  be used by applications, and a special permission is required
  to use them.
  </ul>
                           		---WindowManager.java
<p>以上来源<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/view/WindowManager.java#199">WindowManager#LayoutParams</a>，介绍了Window分为<code>Application windows</code>，<code>Sub-windows</code>，<code>System windows</code>三种。</p>
<h2 id="getsystemservicestr的实现原理">getSystemService(str)的实现原理</h2>
<p>我们知道<code>Context</code>的实现类是<code>ContextImpl</code>，通过查看源码，得到函数的实现为<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/ContextImpl.java#1538">源码</a>。</p>
<pre><code class="language-java">    //ContextImpl.java
    @Override
    public Object getSystemService(String name) {
        return SystemServiceRegistry.getSystemService(this, name);
    }
</code></pre>
<p>OK,在此可以看见，是调用<code>SystemServiceRegistry</code>的静态函数<code>getSystemService(..)</code>来实现的，我们跟着深入，这个函数的实现为<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java#790">源码</a></p>
<pre><code class="language-java">    //SystemServiceRegistry.java
    /**
     * Gets a system service from a given context.
     */
    public static Object getSystemService(ContextImpl ctx, String name) {
        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);
        return fetcher != null ? fetcher.getService(ctx) : null;
    }
</code></pre>
<p>OK，进一步知道是从<code>ServiceFetcher</code>中获取到的，而<code>ServiceFetcher</code>是从<code>SYSTEM_SERVICE_FETCHERS</code>获取到的，跟进知道<code>SYSTEM_SERVICE_FETCHERS</code>的申明为</p>
<pre><code class="language-java">    private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =
            new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();
</code></pre>
<p>是个<code>HashMap</code>，现在我们就要看看数据是在哪里<code>put</code>进去的，通过分析查找，<code>put</code>只在函数<code>registerService()</code>中调用过，所以这些服务一定是通过这里注册的。由于是<code>static final</code>，所以只能在构造函数或静态块进行初始化，这就很方便我们查找。根据查找，可看见实现<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java#151">源码</a>。</p>
<pre><code class="language-java">	static {
        registerService(Context.ACCESSIBILITY_SERVICE, AccessibilityManager.class,
                new CachedServiceFetcher&lt;AccessibilityManager&gt;() {
            @Override
            public AccessibilityManager createService(ContextImpl ctx) {
                return AccessibilityManager.getInstance(ctx);
        }});
        ......
        registerService(Context.WINDOW_SERVICE, WindowManager.class,
               new CachedServiceFetcher&lt;WindowManager&gt;() {
            @Override
            public WindowManager createService(ContextImpl ctx) {
                return new WindowManagerImpl(ctx);
        }});
        ......
	}
    /**
     * Statically registers a system service with the context.
     * This method must be called during static initialization only.
     */
    private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,
            ServiceFetcher&lt;T&gt; serviceFetcher) {
        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);
        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);
    }
</code></pre>
<p>回到上面的<code>fetcher.getService(ctx)</code>函数，它的实现为<a href="https://android.googlesource.com/platform/frameworks/base/+/d0c83cc/core/java/android/app/ContextImpl.java#212">源码</a>。</p>
<pre><code class="language-java">    //代码去除了无用部分
	public Object getService(ContextImpl ctx) {
        service = createService(ctx);
        cache.set(mContextCacheIndex, service);
        return service;
</code></pre>
<p>看到这里，我们知道平时使用<code>WindowManager</code>的真实对象其实是<code>WindowManagerImpl</code>。</p>
<h2 id="window的添加过程">Window的添加过程</h2>
<p>根据上面的分析，知道了<code>WindowManagerImpl</code>才是幕后的凶手，但是真的是这样的吗？我们接着分析。在它的源码中，我们可以看看<a href="https://android.googlesource.com/platform/frameworks/base/+/0e2d281/core/java/android/view/WindowManagerImpl.java">源码</a></p>
<pre><code class="language-java">public final class WindowManagerImpl implements WindowManager {
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    private final Display mDisplay;
    private final Window mParentWindow;
    public WindowManagerImpl(Display display) {
        this(display, null);
    }
    private WindowManagerImpl(Display display, Window parentWindow) {
        mDisplay = display;
        mParentWindow = parentWindow;
    }
    public WindowManagerImpl createLocalWindowManager(Window parentWindow) {
        return new WindowManagerImpl(mDisplay, parentWindow);
    }
    public WindowManagerImpl createPresentationWindowManager(Display display) {
        return new WindowManagerImpl(display, mParentWindow);
    }
    @Override
    public void addView(View view, ViewGroup.LayoutParams params) {
        mGlobal.addView(view, params, mDisplay, mParentWindow);
    }
    @Override
    public void updateViewLayout(View view, ViewGroup.LayoutParams params) {
        mGlobal.updateViewLayout(view, params);
    }
    @Override
    public void removeView(View view) {
        mGlobal.removeView(view, false);
    }
    @Override
    public void removeViewImmediate(View view) {
        mGlobal.removeView(view, true);
    }
    @Override
    public Display getDefaultDisplay() {
        return mDisplay;
    }
}
</code></pre>
<p>卧槽，添加<code>View</code>并不是它在操作，看来真实另有隐情啊。<code>Window</code>的三大操作(add,remove,update)都是有<code>WindowManagerGlobal</code>来实现的。下面分析<code>WindowManagerGlobal</code>,先看看它的内部字段的含义。</p>
<pre><code class="language-java">//存储所有Window对应的View
private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();
//存储所有Window对应的ViewRootImpl
private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();
//存储所有Window对应的布局参数
private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams =
        new ArrayList&lt;WindowManager.LayoutParams&gt;();
//存储正在被删除的View(已经调用remove但remove还没有完成)
private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();
</code></pre>
<p>接下来就是核心部分了，分析<code>addView</code>的<a href="https://android.googlesource.com/platform/frameworks/base/+/0e40462e11d27eb859b829b112cecb8c6f0d7afb/core/java/android/view/WindowManagerGlobal.java#204">源码</a>。</p>
<pre><code class="language-java">public void addView(View view, ViewGroup.LayoutParams params,
        Display display, Window parentWindow) {
    ...... 参数合法判断
    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;
    if (parentWindow != null) {
        //parentWindow != null 表示新建的Window的type为子Window,如Dialog,其主要作用是修改token
        //子Window回共用父Window的token.
        parentWindow.adjustLayoutParamsForSubWindow(wparams);
    } else {
        // If there's no parent and we're running on L or above (or in the
        // system context), assume we want hardware acceleration.
        final Context context = view.getContext();
        if (context != null
                &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) {
            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
        }
    }
    ViewRootImpl root;
    View panelParentView = null;
    synchronized (mLock) {
        // Start watching for system property changes.
        if (mSystemPropertyUpdater == null) {
            mSystemPropertyUpdater = new Runnable() {
                @Override public void run() {
                    synchronized (mLock) {
                        for (int i = mRoots.size() - 1; i &gt;= 0; --i) {
                            mRoots.get(i).loadSystemProperties();
                        }
                    }
                }
            };
            SystemProperties.addChangeCallback(mSystemPropertyUpdater);
        }
        //view在mViews中的位置
        int index = findViewLocked(view, false);
        //找到说明该View已经添加到某个Window
        if (index &gt;= 0) {
            //正在remove
            if (mDyingViews.contains(view)) {
                // Don't wait for MSG_DIE to make it's way through root's queue.
                mRoots.get(index).doDie();
            } else {
                throw new IllegalStateException(&quot;View &quot; + view
                        + &quot; has already been added to the window manager.&quot;);
            }
            // The previous removeView() had not completed executing. Now it has.
        }
        // If this is a panel window, then find the window it is being
        // attached to for future reference.
        if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;
                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
            final int count = mViews.size();
            for (int i = 0; i &lt; count; i++) {
                if (mRoots.get(i).mWindow.asBinder() == wparams.token) {
                    panelParentView = mViews.get(i);
                }
            }
        }
        root = new ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        mViews.add(view);
        mRoots.add(root);
        mParams.add(wparams);
    }
    // do this last because it fires off messages to start doing things
    try {
        root.setView(view, wparams, panelParentView);
    } catch (RuntimeException e) {
        // BadTokenException or InvalidDisplayException, clean up.
        synchronized (mLock) {
            final int index = findViewLocked(view, false);
            if (index &gt;= 0) {
                removeViewLocked(index, true);
            }
        }
        throw e;
    }
}
</code></pre>
<p>看了这么多，我们发现还是没有看见核心代码，那就继续往下看咯，<code>ViewRootImpl</code>这个类。<code>ViewRootImpl</code>是<code>FrameWork</code>层与<code>Native</code>层的通信桥梁。在上面的代码中有实例化它,我们看看具体的实现.</p>
<pre><code class="language-java">public ViewRootImpl(Context context, Displaydisplay) {
    // ① 从WindowManagerGlobal中获取一个IWindowSession的实例。它是ViewRootImpl和WMS进行通信的代理
   mWindowSession= WindowManagerGlobal.getWindowSession(context.getMainLooper());
    // ② 保存参数display，在后面setView()调用中将会把窗口添加到这个Display上
   mDisplay= display;
   CompatibilityInfoHolder cih = display.getCompatibilityInfo();
   mCompatibilityInfo = cih != null ? cih : new CompatibilityInfoHolder();
    // ③ 保存当前线程到mThread。这个赋值操作体现了创建ViewRootImpl的线程如何成为UI主线程。在ViewRootImpl处理来自控件树的请求时（如请求重新布局，请求重绘，改变焦点等），会检查发起请求的thread与这个mThread是否相同。倘若不同则会拒绝这个请求并抛出一个异常
    mThread= Thread.currentThread();
    ......
    // ④ mDirty用于收集窗口中的无效区域。**所谓无效区域是指由于数据或状态发生改变时而需要进行重绘的区域。举例说明，当应用程序修改了一TextView的文字时，TextView会将自己的区域标记为无效区域，并通invalidate()方法将这块区域收集到这里的mDirty中。当下次绘制时，TextView便可以将新的文字绘制在这块区域上
    mDirty =new Rect();
    mTempRect = new Rect();
    mVisRect= new Rect();
    // ⑤ mWinFrame，描述了当前窗口的位置和尺寸。与WMS中WindowState.mFrame保持着一致
    mWinFrame = new Rect();
    // ⑥ 创建一个W类型的实例，W是IWindow.Stub的子类。即它将在WMS中作为新窗口的ID，以及接收来自WMS的回调
    mWindow= new W(this);
    ......
    // ⑦ 创建mAttachInfo。mAttachInfo是控件系统中很重要的对象。它存储了此当前控件树所以贴附的窗口的各种有用的信息，并且会派发给控件树中的每一个控件。这些控件会将这个对象保存在自己的mAttachInfo变量中。mAttachInfo中所保存的信息有WindowSession，窗口的实例（即mWindow）， ViewRootImpl实例，窗口所属的Display，窗口的Surface以及窗口在屏幕上的位置等等。所以，当要需在一个View中查询与当前窗口相关的信息时，非常值得在mAttachInfo中搜索一下
    mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display,this, mHandler, this);
    // ⑧ 创建FallbackEventHandler。**这个类如同PhoneWindowManger一样定义在android.policy包中，其实现为PhoneFallbackEventHandler。FallbackEventHandler是一个处理未经任何人消费的输入事件的场所。在6.5.4节中将会介绍它
    mFallbackEventHandler =PolicyManager.makeNewFallbackEventHandler(context);
    ......
    //⑨ 创建一个依附于当前线程，即主线程的Choreographer，用于通过VSYNC特性安排重绘行为
    mChoreographer= Choreographer.getInstance();
    ......
}
</code></pre>
<p>以上分析来源于<a href="https://wizardforcel.gitbooks.io/deepin-android-vol3/content/6.html">GITBOOK</a>.接着看看<code>mWindowSession</code>是怎么来的。</p>
<pre><code class="language-java">public static IWindowSession getWindowSession() {
     //代码删除干扰部分
     InputMethodManager imm = InputMethodManager.getInstance();
     IWindowManager windowManager = getWindowManagerService();
     sWindowSession = windowManager.openSession(
             new IWindowSessionCallback.Stub() {
                   @Override
                   public void onAnimatorScaleChanged(float scale) {
                          ValueAnimator.setDurationScale(scale);
                   }
             },
             imm.getClient(),
             imm.getInputContext());
     return sWindowSession;
}
</code></pre>
<p>通过Google搜索，我们发现<code>IWindowManager</code>其实是一个<code>AIDL</code>文件,<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/IWindowManager.aidl">代码在此</a>,也就是说，这里的实现其实是进程间的通信，继续跟进下<code>getWindowManagerService()</code>的实现。</p>
<pre><code class="language-java">public static IWindowManager getWindowManagerService() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowManagerService == null) {
                sWindowManagerService = IWindowManager.Stub.asInterface(
                        ServiceManager.getService(&quot;window&quot;));
                ......        
            }
            return sWindowManagerService;
        }
    }
</code></pre>
<p>根据我们已有的AIDL的知识，我们知道<code>ServiceManager.getService(&quot;window&quot;)</code>返回的其实是一个<code>IBinder</code>,这里接着看看到底返回的是什么？<a href="https://android.googlesource.com/platform/frameworks/base/+/0e2d281/core/java/android/os/ServiceManager.java#49">在源码中</a>查看。</p>
<pre><code class="language-java">public static IBinder getService(String name) {
     ...
     return getIServiceManager().getService(name);
     ...
}
public static void addService(String name, IBinder service) {
    getIServiceManager().addService(name, service, false);
}
</code></pre>
<p>所以，所有的服务都是通过<code>addService</code>添加到<code>ServiceManager</code>,然后通过<code>getService</code>取出，但是是怎么添加，每个服务具体的类是什么？我们只要看看哪里调用<code>addService</code>即可。<a href="https://android.googlesource.com/platform/frameworks/base.git/+/22f7dfd23490a3de2f21ff96949ba47003aac8f8/services/java/com/android/server/SystemServer.java#97">源码</a></p>
<pre><code class="language-java">try {
  power = new PowerManagerService();
  ServiceManager.addService(Context.POWER_SERVICE, power);
  ....
  wm = WindowManagerService.main(context, power,
                   factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL);
  ServiceManager.addService(Context.WINDOW_SERVICE, wm);//Context.WINDOW_SERVICE = &quot;window&quot;
}
...
</code></pre>
<p>在<code>WindowManagerService.main(...)</code>中，我们可以看到返回的其实是	<code>WindowManagerService</code>。而<code>WindowManagerService</code>的声明为</p>
<pre><code class="language-java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs{}

class IWindowManager.Stub extends android.os.Binder{}

public class Binder implements IBinder{}
</code></pre>
<p>这里可以看到,这是很普通的一个AIDL的实现.回到函数<code>getWindowSession()</code>,</p>
<pre><code class="language-java">IWindowManager windowManager = getWindowManagerService();
sWindowSession = windowManager.openSession(
        new IWindowSessionCallback.Stub() {
              @Override
              public void onAnimatorScaleChanged(float scale) {
                     ValueAnimator.setDurationScale(scale);
              }
        },
        imm.getClient(),
        imm.getInputContext());
</code></pre>
<p>我们知道了<code>windowManager</code>其实是<code>WindowManagerService</code>,所以看看<code>openSession</code>的具体实现。</p>
<pre><code class="language-java">@Override
public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,IInputContext inputContext) {
    if (client == null) throw new IllegalArgumentException(&quot;null client&quot;);
    if (inputContext == null) throw new IllegalArgumentException(&quot;null inputContext&quot;);
    Session session = new Session(this, callback, client, inputContext);
    return session;
}
</code></pre>
<p>可以看见<code>Session</code>的签名如下,我们知道它是<code>IWindowSession.aidl</code>的具体实现.</p>
<pre><code class="language-java">final class Session extends IWindowSession.Stub
        implements IBinder.DeathRecipient{}
</code></pre>
<blockquote>
<p>This class represents an active client session.  There is generally one<br>
Session object per process that is interacting with the window manager.</p>
</blockquote>
<p><code>WindowManagerGlobal</code>的<code>addView()</code>最终调用的了<code>ViewRootImpl</code>的<code>setView()</code>方法,那么这个方法又是做什么用的?</p>
<pre><code class="language-java">// Schedule the first layout -before- adding to the window
// manager, to make sure we do the relayout before receiving
// any other events from the system.
requestLayout();
...
try {
    ...
    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
            getHostVisibility(), mDisplay.getDisplayId(),
            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
            mAttachInfo.mOutsets, mInputChannel);
} catch (RemoteException e) {} finally {}
</code></pre>
<p>上面代码中的<code>requestLayout()</code>会调用<code>scheduleTraversals()</code>方法,而该方法最终会调用<code>performTraversals()</code>,该函数就是android系统View树遍历工作的核心。执行过程可简单概括为根据之前所有设置好的状态，判断是否需要计算视图大小（measure）、是否需要重新安置视图的位置（layout），以及是否需要重绘（draw）视图,这里我不会进一步分析.下面看看<code>mWindowSession.addToDisplay()</code>的调用,我们知道<code>mWindowSession</code>就是<code>Session</code>,这个函数的实现为</p>
<pre><code class="language-java">@Override
public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
        int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
        Rect outOutsets, InputChannel outInputChannel) {
          //mService 是WindowManagerService ,构造函数中赋的值
    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
            outContentInsets, outStableInsets, outOutsets, outInputChannel);
}
</code></pre>
<p>可以看出，Window的添加请求就交给WindowManagerService去处理了。addView大概一个过程如下：</p>
<blockquote>
<p>WindowManagerImpl——&gt;WindowManagerGobal——&gt;ViewRootImpl——&gt;Session——&gt;WindowManagerService</p>
</blockquote>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://wizardforcel.gitbooks.io/deepin-android-vol3/content/6.html">深入理解控件（ViewRoot）系统</a></li>
<li><a href="http://blog.csdn.net/qianhaifeng2012/article/details/51737370">Android中的ViewRootImpl类源码解析</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Instance Run 原理分析]]></title>
        <id>https://kutear.github.io/post/Instant_Run_原理</id>
        <link href="https://kutear.github.io/post/Instant_Run_原理">
        </link>
        <updated>2018-01-19T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="instant-run-原理">Instant run 原理</h1>
<p>编译期对所有方法进行插桩</p>
<p>例如原始代码</p>
<pre><code class="language-java">class Main{
    public void func(Context ctx){
         Toast.makeText(ctx,&quot;Hello&quot;,Toast.LENGTH_LONG).show();
    }
}
</code></pre>
<p>编译之后再<code>/build/intermediates/transforms/instantRun/Debug/{Num}/</code>下面存在插桩后的class文件[第一次生成的代码],{Num}似乎在不同环境下数值不一样</p>
<pre><code class="language-java">class Main{  
    public void func(Context ctx) {
        IncrementalChange var2 = $change;
        if(var2 != null) {
          var2.access$dispatch(&quot;func.(Landroid/content/Context;)V&quot;, new Object[]{this, ctx});
        } else {
          Toast.makeText(ctx, &quot;Hello&quot;, 1).show();
        }
      }
}
</code></pre>
<p>所以当某个类有了新的变化，只需要给<code>$change</code>字段赋值,就可以达到方法替换的目的(类似与代理)，或许你发现生成的class文件中没有<code>$change</code>的相关定义说明，我们可以通过反编译<code>/build/intermediates/transforms/dex/</code>下面的<code>dex</code>文件发现其中<code>$change</code>的定义为</p>
<pre><code class="language-java">public static volatile transient /* synthetic */ IncrementalChange $change = null;
</code></pre>
<p>使用<code>Instant Run</code>运行之后会在<code>/build/intermediates/transforms/instantRun/Debug/{Num2}/</code> 下生成出变化的class,{Num2}不同与上文的{Num}</p>
<pre><code class="language-java">public class Main$override implements IncrementalChange {
  public static void func(Main $this, Context ctx) {
    Toast.makeText(ctx, &quot;Hello&quot;, 1).show();
  }
  ...
}
</code></pre>
<p>同时还会生成一个类<code>com.android.tools.ir.runtime.AppPatchesLoaderImpl(extends AbstractPatchesLoaderImpl)</code>,在他的<code>getPatchedClasses()</code>函数中会返回所有改变了的类的全名,用于后续替换的需要。</p>
<p>然后将这些变化了的class打包成为(命令dx)dex通过<code>socket</code>发送给Client,Client拿到这个dex之后找到拿到变化了的class,并通过反射对<code>$change</code>字段进行修改，从而完成方法体的提换。</p>
<h2 id="差分dex生成">差分dex生成</h2>
<h2 id="如何实现插桩">如何实现插桩</h2>
<p>在Android Gradle1.5插件中，Google加入了一个Transform api,这个api的作用是可以操作编译之后的class文件,目前修改class文件的方式有javaasist等等第三方库,我没有看Android Gradle插件的具体的插桩的过程,这里我们可以看看javaasist的插桩的一种实现。</p>
<p>首先注册一个自己的Transform到Android Gradle中<code>project.android.registerTransform(new MyTranform(...))</code>,<code>MyTranform</code>继承自<code>Transform</code>,核心实现<code>void tranform(TransformInvocation invocation)</code>方法，我们可以冲参数中获取到传入的class dir以及 jar包。在结合javaasist对class字节码进行修改输出，就可以实现插桩。基于同样的原理，我们可以实现一个插桩(方法的开头和结尾处)来对每个方法进行耗时统计(注意递归调用的情况)，也可以通过注入一个字段来进行对类实例的个数进行统计(注意子类对父类的影响)。</p>
<h2 id="双端socket通信">双端Socket通信</h2>
<p>两端通信就是以手机端为Server,Gradle插件作为Client,Gradle插件向手机发送本次变更的类的列表,以及变更之后的一个差分patch,服务端收到patch之后保存在本地的目录,然后反射注入一些对象都待修改的类中去。</p>
<h2 id="client-端动态加载dex实现hot-swap">Client 端动态加载Dex实现Hot Swap</h2>
<p>注:这里的手机端其实是服务端</p>
<p>我们知道这个编译之后的增量包是Android Studio通过Socket穿给手机的,具体的位置在<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/Server.java#318">MESSAGE_PATCHES</a></p>
<pre><code class="language-java">case MESSAGE_PATCHES: {
    if (!authenticate(input)) {
        return;
    }
	//通过数据流读取字节码存在byte[]中
    List&lt;ApplicationPatch&gt; changes = ApplicationPatch.read(input);
    boolean hasResources = hasResources(changes);
    int updateMode = input.readInt();
    updateMode = handlePatches(changes, hasResources, updateMode);
    restart(updateMode, hasResources, showToast);
    continue;
}
</code></pre>
<p>在函数<code>handlePatches(...)</code>会对修改的文件进行处理,分为资源文件和dex文件</p>
<pre><code class="language-java">for(ApplicationPatch change : changes) {
   String path = change.getPath();
   if (path.equals(RELOAD_DEX_FILE_NAME)) {
         updateMode = handleHotSwapPatch(updateMode, change);
   } else if (isResourcePath(path)) {
         updateMode = handleResourcePatch(updateMode, change, path);
   }
}
</code></pre>
<h3 id="dex-swap">Dex Swap</h3>
<p>这里我们先看对于dex的处理,首先将byte[]的dex写到本地,然后新建一个<code>ClassLoader</code>来加载这个类,通过实例化一个类然后调用其<code>load()</code>函数。</p>
<pre><code class="language-java">try {
    String dexFile = FileManager.writeTempDexFile(patch.getBytes());
  	...
    String nativeLibraryPath = FileManager.getNativeLibraryFolder().getPath();
    DexClassLoader dexClassLoader = new DexClassLoader(dexFile,
               context.getCacheDir().getPath(), nativeLibraryPath,
               getClass().getClassLoader());
            // we should transform this process with an interface/impl
    Class&lt;?&gt; aClass = Class.forName(
                    &quot;com.android.tools.fd.runtime.AppPatchesLoaderImpl&quot;, true, dexClassLoader);
    try {
	     ...
         PatchesLoader loader = (PatchesLoader) aClass.newInstance();
         ...
         if (!loader.load()) { //核心逻辑
            updateMode = UPDATE_MODE_COLD_SWAP;
         }
     } catch (Exception e) {
         e.printStackTrace();
         updateMode = UPDATE_MODE_COLD_SWAP;
     }
} catch (Throwable e) {
    updateMode = UPDATE_MODE_COLD_SWAP;
}
</code></pre>
<p><code>load()</code>函数的具体实现在<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-runtime/src/main/java/com/android/tools/fd/runtime/AbstractPatchesLoaderImpl.java#30">AbstractPatchesLoaderImpl#load</a>,根据前文的介绍,我们知道这里的最终目的一定是将更改之后的类的一个代理对象赋值给<code>$change</code>字段,下面看看具体的做法。</p>
<pre><code class="language-java">for (String className : getPatchedClasses()) { //获取修改类的全名
     ClassLoader cl = getClass().getClassLoader();
     Class&lt;?&gt; aClass = cl.loadClass(className + &quot;$override&quot;);
     Object o = aClass.newInstance();
     Class&lt;?&gt; originalClass = cl.loadClass(className);
     Field changeField = originalClass.getDeclaredField(&quot;$change&quot;);
     // force the field accessibility as the class might not be &quot;visible&quot;
     // from this package.
     changeField.setAccessible(true);
	 // If there was a previous change set, mark it as obsolete:
     Object previous = changeField.get(null);
     if (previous != null) {
          Field isObsolete = previous.getClass().getDeclaredField(&quot;$obsolete&quot;);
          if (isObsolete != null) {
               isObsolete.set(null, true);
          }
      }
      changeField.set(null, o);
}
</code></pre>
<p>实现非常的简单就是通过反射修改静态字段<code>$change</code>的值。这样以后在调用的时候就能使用新的方法实现。</p>
<h3 id="res-swap">Res Swap</h3>
<p>资源替换的一个前提就是id固定,我们都知道资源id是每次编译时生成的,每次编译必然会导致id变化，如何任由它变化就是造成ResourceNotFound,如何实现资源固定网上有很多的说明，我不再重复。</p>
<blockquote>
<p>简要说来，Instant Run中的资源热修复分为两步，</p>
<p>1、构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完整的新资源包加入到AssetManager中。这样就得到了一个含有所有新资源的AssetManager。</p>
<p>2、找到所有之前引用到原有AssetManager的地方，通过反射，把引用处替换为AssetManager。</p>
</blockquote>
<p>具体的代码实现在这里可以查看<a href="https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/MonkeyPatcher.java#90">instant-run</a></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/">Instant Run Source Code</a></li>
<li><a href="http://jiajixin.cn/2015/11/25/instant-run/">Instant Run 浅析</a></li>
<li><a href="https://halfstackdeveloper.github.io/2016/09/23/%E5%9F%BA%E4%BA%8EInstant-Run%E6%80%9D%E6%83%B3%E7%9A%84HotFix%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0/">基于Instant-Run思想的HotFix方案实现</a></li>
<li><a href="http://www.jianshu.com/p/417589a561da">通过自定义Gradle插件修改编译后的class文件</a></li>
<li><a href="http://www.jianshu.com/p/e6125ddfaea7">Android资源动态加载思路</a></li>
<li><a href="https://yq.aliyun.com/articles/96378">Android热修复升级探索——资源更新之新思路</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit 原理分析]]></title>
        <id>https://kutear.github.io/post/2017-07-01-Android_Retrofit</id>
        <link href="https://kutear.github.io/post/2017-07-01-Android_Retrofit">
        </link>
        <updated>2017-07-01T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<p>注:本文不会涉及<code>retrofit</code>的使用</p>
<h1 id="前言">前言</h1>
<p>目前Android开发主流的网络请求框架要数<code>OKHTTP</code>了,<code>retrofit</code>就是在<code>OKHTTP</code>的基础之上进行了一层封装,使得开发者使用更加的方便.如果你要问具体方便在哪里?其实就是对于请求参数的构建这一块更加的方便.使用<code>OKHTTP</code>的时候需要我们自己去构建一个<code>Request</code>对象,而<code>Retrofit</code>直接使用注解声明的方式自动帮助我们创建<code>Request</code>对象.还有一方面就是对于请求的返回值,<code>Retrofit</code>可以使用<code>Converter</code>去把返回值直接返回为具体的实例.如果结合<code>RxJava</code>使用效果更加的好.</p>
<p>说明:以下分析基于retrofit版本2.1.0</p>
<h1 id="分析">分析</h1>
<h2 id="retrofit实例构建部分">Retrofit实例构建部分</h2>
<p><code>Retrofit</code>的构建使用常用的Builder模式,其中构建的参数包括<code>OkHttpClient</code>,<code>Converter.Factory</code>,以及<code>CallAdapter.Factory</code>,他们的作用分别是<code>OkHttp</code>请求的Client,转换请求得到的数据为具体的类型,以及根据接口申明调用的不用的构建<code>Request</code>的工厂.其中<code>Converter.Factory</code>和<code>CallAdapter.Factory</code>的数量可以是多个.</p>
<p>构建好<code>Retrofit</code>的实例之后我们就可以使用它来创建网络接口.</p>
<p>在<code>Retrofit#create(...)</code>中,会使用java动态代理实现对网络接口类的访问.下面部分将会分析如何根据注解生成一个<code>Request</code>对象提供给<code>OKHTTP</code>模块使用,如何处理返回的数据转换为我们期望的类型.</p>
<h2 id="接口创建过程">接口创建过程</h2>
<p>动态代理相关的知识这里就不多说,我们把焦点集中在<code>Retrifit#create(...)</code>上,在第一行对接口类进行验证,要求必须是接口,并且没有继承至别的接口.紧接着是<code>validateEagerly</code>条件判断,这个字段是构建<code>Retrofit</code>的过程中外部赋值,如果为<code>true</code>表示在构建API接口的时候就行预先加载,可以看成是单例模式中的饿汉实现,然后就是一个动态代理,在对方法的代理时,会过滤掉默认方法,比如<code>Object</code>的相关方法,以及Java8所支持的默认接口实现方法,也就是说这些方法不是一个真正的接口的实现.代理内部最后三行代码才是我们分析的核心.</p>
<pre><code class="language-java">ServiceMethod serviceMethod = loadServiceMethod(method);
OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre>
<p>先概括的描述其各自的作用,第一行根据<code>method</code>解析他的注解得到一个<code>ServiceMethod</code>,<code>ServiceMethod</code>包含了请求所需要的字段,链接,类型等信息,第二行根据调用时的具体参数赋予上文构建出来的<code>ServiceMethod</code>,从而得到一个<code>Call</code>对象.该对象和<code>okhttpclient.newCall(...)</code>得到的效果一致(不是同一个接口,只是名字都是<code>Call</code>罢了),而最后行就是处理这个<code>Call</code>,<code>Retrofit</code>默认是没有做任何的处理</p>
<h2 id="servicemethod的构建">ServiceMethod的构建</h2>
<p><code>serviceMethod</code>的构建也是使用builder模式,<code>new ServiceMethod.Builder(retrofit, method).build()</code>.其核心的内容就在这个<code>build()</code>方法之中.</p>
<p>在<code>build()</code>开始先是获取到一个<code>CallAdapter</code>,这个值怎么来的呢?其实是创建<code>Retrofit</code>时设置的<code>CallAdapter.Factory</code>进行创建的,规则是根据method的返回值和注解来查找构建具体的<code>CallAdapter</code>,具体的可以查看<code>Factory#get(...)</code>函数,例如<code>DefaultCallAdapterFactory#get(...)</code>只会判断method的返回类型是否为<code>Call</code>.基于同样的原理,有创建一个<code>Converter&lt;ResponseBody, T&gt;</code>用来将<code>OKHTTP</code>返回的<code>ResponseBody</code>转化为具体的类型<code>T</code>,在<code>build()</code>方法的后面部分,就是将method上的所用的注解都映射成为请求时的参数.其中method的每个参数都会对应到一个<code>ParameterHandler&lt;?&gt;</code>上,根据不同的注解,会用不同类型的<code>ParameterHandler&lt;?&gt;</code>,比如<code>Field</code>注解就对应上一个<code>ParameterHandler.Field&lt;?&gt;</code>,这样的目的就是后续对请求参数进行赋值的时候,各个<code>ParameterHandler&lt;?&gt;</code>只需要处理一种类型的数据格式.</p>
<h2 id="okhttpcall作用">OkHttpCall作用</h2>
<p><code>OkHttpCall</code>实现了<code>Call</code>接口,本质上这个<code>Call</code>和<code>okhttp3.Call</code>没有任何关系,但是他们的用法几乎一直,使用过<code>OKHTTP</code>的同学都知道,<code>Response response = client.newCall(request).execute();</code>,从<code>OkHttpClient#newCall(...)</code>得到的就是一个<code>okhttp3.Call</code>对象,通过这个对象我们可以执行同步或异步请求.既然是这样,那我们的<code>OkHttpCall</code>必定和<code>OkHttpClient</code>会有关联,果不其然,在<code>OkHttpCall</code>内部存在一个真正的<code>okhttp3.Call</code>,而这个<code>okhttp3.Call</code>代理了<code>OkHttpCall</code>的所用方法,那么这个<code>okhttp3.Call</code>是从哪里来的?</p>
<pre><code class="language-java">  private okhttp3.Call createRawCall() throws IOException {
    Request request = serviceMethod.toRequest(args);
    okhttp3.Call call = serviceMethod.callFactory.newCall(request); //构建retrofit时传入
    if (call == null) {
      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
    }
    return call;
  }
</code></pre>
<p>我们发现这里的逻辑就是我们直接使用<code>OKHTTP</code>时的获取<code>okhttp3.Call</code>的逻辑,第一行进行构建<code>Request</code>,因为开始我们的<code>serviceMethod</code>已经有了所用的请求的基本字段信息,就差每个请求的具体值,在这里就是把具体的值进行设置,而赋值的过程就是使用上文提及的<code>ParameterHandler&lt;?&gt;#apply(...)</code>方法,赋完值之后得到一个<code>Request</code>对象.从而获得一个可用的<code>Call</code>对象.</p>
<h2 id="数据解析">数据解析</h2>
<p>得到上文的<code>Call</code>后使用同步或异步的方式进行请求,<code>OkHttpCall</code>内部先接收到响应,对数据进行处理之后在抛给调用者,而这里的处理过程就是数据解析的过程.在<code>OkHttpCall#parseResponse()</code>中就是这个过程的处理,这里面使用了<code>ServiceMethod</code>构建时的<code>Converter&lt;ResponseBody, T&gt;</code>对象进行装换,也就是将<code>ResponseBody</code>转为具体的<code>T</code>类型,具体可以参考<code>GsonResponseBodyConverter</code></p>
<h1 id="尾声">尾声</h1>
<p>通过上面的说明,应该大体上了解了<code>Retrofit</code>的工作流程,当然很多时候我们会将他和<code>RxJava</code>结合在一起使用,我会在下一篇文章中说明一下.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeakCanary 原理分析]]></title>
        <id>https://kutear.github.io/post/2017-05-30-Android_Leakcanary</id>
        <link href="https://kutear.github.io/post/2017-05-30-Android_Leakcanary">
        </link>
        <updated>2017-05-30T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="reference-与-referencequeue">Reference 与 ReferenceQueue</h2>
<p>关于强软弱虚四种引用类型这里不会多说,但是多数时候我们都是最简单的使用这些类,很少涉及到其中的<code>ReferenceQueue</code> ,在所以引用的基类<code>Reference</code>中有一个构造函数<code>Reference(T referent, ReferenceQueue&lt;? super T&gt; queue)</code>,其中传入了一个<code>ReferenceQueue</code>,他的作用就是当被观察(使用引用的对象)的对象被JVM GC之后会将其加入到这个队列.</p>
<h2 id="leakcanary-分析">LeakCanary 分析</h2>
<p>通过上文的描述,当我们观察一个对象被回收之后,我们是可以知道的(通过读取<code>ReferenceQueue</code>中的值),放到Android上面来讲,内存泄露问题主要是发生在<code>Activity</code>上,当一个<code>Activity</code>被destory之后,就应该被回收,但是由于错误的引用,导致并不能被正常的回收.基于上面的描述,我们可以实现当<code>Activity</code>被destory之后,就开始观察他的回收,如果发生了GC,但是这个<code>Activity</code>依旧没有被回收,那么他就有可能发生了泄露.下面看看<code>LeakCanary</code>具体是怎么做的.</p>
<p>根据<code>LeakCanary</code>使用指南,我们知道入口函数</p>
<pre><code class="language-java">  public static RefWatcher install(Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
        .buildAndInstall();
  }
</code></pre>
<p>这里我们不细细分析具体过程,直接看看<code>buildAndInstall</code>函数.</p>
<pre><code class="language-java">  public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
      LeakCanary.enableDisplayLeakActivity(context);
      ActivityRefWatcher.install((Application) context, refWatcher);
    }
    return refWatcher;
  }
</code></pre>
<p>在<code>ActivityRefWatcher.install(...)</code>中最终调用了下面的代码</p>
<pre><code class="language-java">  public void watchActivities() {
    // Make sure you don't get installed twice.
    stopWatchingActivities();
    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
  }
</code></pre>
<p>也就是我们平时也会使用的<code>registerActivityLifecycleCallbacks</code>,在<code>lifecycleCallbacks</code>的<code>onActivityDestroyed(Activity activity)</code>中最终会调用<code>refWatcher.watch(activity);</code> ,其中<code>refWatcher</code>是<code>RefWatcher</code>的一个实例,<code>watch(activity)</code> 会调用他的重载函数</p>
<pre><code class="language-java">  public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
      return;
    }
    checkNotNull(watchedReference, &quot;watchedReference&quot;);
    checkNotNull(referenceName, &quot;referenceName&quot;);
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key);
    final KeyedWeakReference reference =
        new KeyedWeakReference(watchedReference, key, referenceName, queue); //WeakReference的子类  这里的queue就是上文多次提及的ReferenceQueue

    ensureGoneAsync(watchStartNanoTime, reference);
  }

  private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
    watchExecutor.execute(new Retryable() {
      @Override public Retryable.Result run() {
        return ensureGone(reference, watchStartNanoTime);
      }
    });
  }
</code></pre>
<p>可以看到最后调用<code>watchExecutor.execute(...)</code> 这里的<code>watchExecutor</code>是<code>AndroidWatchExecutor</code>,对应的函数为</p>
<pre><code class="language-java"> @Override public void execute(Retryable retryable) {
    //?? 为什么一定要在主线程执行??
    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
      waitForIdle(retryable, 0);
    } else {
      postWaitForIdle(retryable, 0);  //使用主线程的handler重新post到waitForIdle(...)上.
    }
  }
 
 void waitForIdle(final Retryable retryable, final int failedAttempts) {
    // This needs to be called from the main thread.
    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
      @Override public boolean queueIdle() {
        postToBackgroundWithDelay(retryable, failedAttempts);
        return false;
      }
    });
  }

  void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
    long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor);
    long delayMillis = initialDelayMillis * exponentialBackoffFactor;
    backgroundHandler.postDelayed(new Runnable() {
      @Override public void run() {
        Retryable.Result result = retryable.run(); //上文ensureGone(reference, watchStartNanoTime)的结果
        if (result == RETRY) {
          postWaitForIdle(retryable, failedAttempts + 1);
        }
      }
    }, delayMillis);
  }
</code></pre>
<p>所以最后的执行其实就是<code>ensureGone(reference, watchStartNanoTime)</code>这里,这就是具体的判断泄露的过程,</p>
<pre><code class="language-java">Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    long gcStartNanoTime = System.nanoTime();
    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);

    removeWeaklyReachableReferences();

    if (debuggerControl.isDebuggerAttached()) {
      // The debugger can create false leaks.
      return RETRY;
    }
    if (gone(reference)) {
      return DONE;
    }
    gcTrigger.runGc();   // 强制发生GC
  
    removeWeaklyReachableReferences();
  
  
  	//如果发生了GC该对象依旧没有被回收,那么就有可能发生了内存泄露
  	//就会到出heap进行分析
    if (!gone(reference)) {
      long startDumpHeap = System.nanoTime();
      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);

      File heapDumpFile = heapDumper.dumpHeap();
      if (heapDumpFile == RETRY_LATER) {
        // Could not dump the heap.
        return RETRY;
      }
      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
      heapdumpListener.analyze(
          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
              gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
  }

 private boolean gone(KeyedWeakReference reference) {
    return !retainedKeys.contains(reference.key);
  }

  private void removeWeaklyReachableReferences() {
    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
    // reachable. This is before finalization or garbage collection has actually happened.
    KeyedWeakReference ref;
    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
      retainedKeys.remove(ref.key);
    }
  }
</code></pre>
<p>好了,到此我们就知道了<code>LeakCanary</code>检测内存泄露的方法及过程,对于heap内存的导出并没分析,这确实也是比较重要的,在后续有空在弄一下.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抛开源码讲流程-Volley]]></title>
        <id>https://kutear.github.io/post/2017-04-21-Android_Volley</id>
        <link href="https://kutear.github.io/post/2017-04-21-Android_Volley">
        </link>
        <updated>2017-04-21T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本实现">基本实现</h2>
<p>创建单例RequestQueue来同一调度所有的Request,RequestQueue内部包含一个CacheQueue和一个NetworkQueue,分别存储缓存请求和网络请求序列。通过RequestQueue的add()函数向RequestQueue中添加请求。如果该请求应该被缓存那么就将他添加到CacheQueue，而CacheDispatcher(Thread)会处理CacheQueue中的请求事件，当这个请求在以前已经请求过，并且缓存的内容还没有过期，就会使用ResponseDelivery将缓存的结果通过Handler发送到主线程，如果缓存不存在或者已经过期就会将这个请求添加到NetworkQueue。如果该请求不允许被缓存，那么就会直接将这个请求添加到NetworkQueue，会有一个NetworkDispatcher(Thread，他的实例存在多个)来处理NetworkQueue中的请求事件，通过网络请求得到数据，如果是可以被缓存的请求，就先把返回的数据缓存后再利用ResponseDelivery将缓存的结果通过Handler发送到主线程。</p>
<h2 id="谈谈阻塞队列">谈谈阻塞队列</h2>
<p>上文中的RequestQueue和NetworkQueue的数据类型都是PriorityBlockingQueue，PriorityBlockingQueue 是一个支持优先级排序的无界阻塞队列。使用它的原因是因为Volley是支持并发的，NetworkQueue实例只有一个，但是却有多个NetworkDispatcher从中读取请求并执行请求，因此需要使用并发支持。</p>
<blockquote>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
</blockquote>
<p>在我们Volley框架中，显然以我们发送请求作为生产者，多个NetworkDispatcher(Thread)作为消费者。当队列中没有请求的时候，所有的NetworkDispatcher都会因为不能从队列中读到数据而进入阻塞状态。当队列中的请求数量达到队列的最大值时，我们发送请求的线程会进入阻塞，而发送请求的线程通常就是我们我的主线程，当然不允许阻塞，故选用队列要求是无界队列(容量不会满，主线程不会阻塞)</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法\处理方式</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th style="text-align:center">一直阻塞</th>
<th style="text-align:center">超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入方法</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">put(e)</td>
<td style="text-align:center">offer(e,time,unit)</td>
</tr>
<tr>
<td style="text-align:center">移除方法</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take()</td>
<td style="text-align:center">poll(time,unit)</td>
</tr>
<tr>
<td style="text-align:center">检查方法</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>
<p>在Volley的实现中，向队列添加Request就是通过put(e)进行的，而NetworkDispatcher从队列中获取Request就是通过take()进行的。</p>
<p>更多关于并发阻塞队列可以参考<a href="http://www.infoq.com/cn/articles/java-blocking-queue">infoQ</a></p>
<h2 id="网络请求部分">网络请求部分</h2>
<p>在没有特别指明的情况下，Volley在API&gt;=9时是使用HttpUrlConnect(封装为HurlStack),当API&lt;9时是使用HttpClient(封装为HttpClientStack)，并将HurlStack或HttpClientStack在封装到Network对象中去。上文提到网络请求最终会在NetworkDispatcher这个线程中执行，其执行的逻辑就是从队列中获取到Request，然后交给Network对象去做真正的请求，上文说过Network包含了HurlStack或HttpClientStack，对于不用的Android版本就分别委托不同的HttpStack去做请求，请求部分的代码平时大家都有写过，就跳过了。最终在NetworkDispatcher中拿到了请求回来的数据的封装NetworkResponse。</p>
<h2 id="数据解析">数据解析</h2>
<p>由于不同的请求会返回不同的数据类型，比如文件的二进制，普通的字符等等，所以把数据的解析委托给对应的Request，在NetworkDispatcher中拿到了NetworkResponse(content数据格式为字节数组)之后，通过Request#parseNetworkResponse(NetworkResponse)解析得到不同类型的Response&lt;?&gt;，比如Json就是将NetworkResponse持有的字节数组转化为对应的JsonBean。</p>
<h2 id="其他细节">其他细节</h2>
<p>重试机制，在每个Request中持有有个RetryPolicy，用于控制在什么情况下会进行重试，实现非常简单，就是在Network做网络请求时，如果遇到错误，但是RetryPolicy还满足条件，就会继续重新请求，直到不再满足RetryPolicy或者请求成功为止。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抛开源码讲流程-AsyncTask]]></title>
        <id>https://kutear.github.io/post/2017-04-20-Android_AsyncTask</id>
        <link href="https://kutear.github.io/post/2017-04-20-Android_AsyncTask">
        </link>
        <updated>2017-04-20T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本原理">基本原理</h2>
<p>其实AsyncTask的原理非常的简单，就是通过线程池执行一个异步任务并将异步任务的结果通过Handler抛到主线程。</p>
<h2 id="实现方式">实现方式</h2>
<p>在构造函数中创建了一个WorkerRunnable(并不是继承至Runnable而是Callable)对象和 一个FutureTask(继承至Runnable)对象，并且引用了WorkerRunnable对象。在执行AsyncTask#execute(...)时，其实就是先执行一个onPreExecute()函数，然后把我们的参数放进WorkerRunnable，并把FutureTask对象再封装到一个Runnable中放入一个待执行的队列(static)，如果当前没有任务在执行，就从队列中提取出这个FutureTask对应的Runnable，否则等待正在执行的任务执行完毕之后在提取下一个待执行任务(封装了FutureTask的Runnable)。到此，不管怎样，任务已经到队列中了，始终会轮到他执行。那怎么执行会干什么呢?上文说过使用Runnable封装的FutureTask其实也是一个Runnable,并且持有WorkerRunnable对象的引用。在FutureTask#run()中就是调用了WorkerRunnable#call()方法，而这个call()方法会调用doInBackground()函数并取得后台计算的结果，在call()的最后通过postResult()函数使用Handler发送消息到主线程，在主线程中执行了finish()，而finish()调用了我们很关心的onPostExecute()或onCancelled()(当调用了AsyncTask的cancel()方法的时候)方法，到此，三个重要的方法onPreExecute(),doInBackground(),onPostExecute()的调用逻辑就理清楚了。另外，有时在doInBackground()会使用publishProgress()来更新进度,publishProgress()内部也是使用Handler发送消息到主线程达到在主线程调用onProgressUpdate()的目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抛开源码讲流程-Handler]]></title>
        <id>https://kutear.github.io/post/2017-04-19-Android_Handler</id>
        <link href="https://kutear.github.io/post/2017-04-19-Android_Handler">
        </link>
        <updated>2017-04-19T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本原理">基本原理</h2>
<p>Handler在构造函数中会通过Looper.myLooper()获取到当前线程的Looper对象,以及获取到Looper的MessageQueue对象。当Handler发送一个消息的时候，其实就是向这个MessageQueue中存放一个Message对象，这个Message对象引用了Handler，在Looper的loop函数中，会从MessageQueue的next()函数中不断的获取Message对象，前面说过，Message含有Handler对象，这里对于Message的处理也是转交给Handler的diapatchMessage函数处理。对于一个Message的处理有三种方式，优先级从高到低依次是Message的calllBack,然后是Handler的callback，最后才是Handler的handlerMessage()方法。</p>
<h2 id="关于线程切换">关于线程切换</h2>
<p>对于线程的切换其实就是A线程(Looper所在线程)持有一个MessageQueue，B线程（Handler发送消息的线程）引用A线程中的MessageQueue对象，并向这个MessageQueue中插入Message对象，然后在A线程的Looper.loop()中取出这个Message对象，并对这个Message进行处理。所以对于消息的处理就由B线程切换到了A线程。</p>
<h2 id="单一线程looper唯一性">单一线程Looper唯一性</h2>
<p>在一个线程中只能存在Looper对象，Android主线程在ActivityThread的main函数中其实已经创建了,所以我们不能再在主线程进行Looper的创建。线程Looper唯一性的保证是ThreadLocal类实现。在Looper中含有ThreadLocal的静态字段，在创建Looper的之前会先检查是否当前线程已经存在Looper，存在的话会抛出异常。可以正常创建的话就创建对象，然后通过ThreadLocal使创建了的Looper对象绑定到当前线程的localValues中。后续获取当前线程的Looper对象是通过Looper.myLooper()，这个函数的实现就是通过ThreadLocal在当前线程中的localValues中取出Looper对象。</p>
<h2 id="message对象池">Message对象池</h2>
<p>官方推荐使用Message#obtain()来创建Message对象，原因就是Message存在一个对象池(static)，这个对象池的数据结构其实是Message为节点的一条链表。这个对象池的大小最大可为50。使用obtain()获取Message对象的时候是先从Message对象池中读取链表的头节点，并将读的对象相关标记位(正在使用)制空，如果链表节点数目为0，就只能创建新对象了。</p>
<h2 id="其他小细节">其他小细节</h2>
<p>MessageQueue的实现其实是通过链表来实现的，而链表的节点就是上文的Message对象。</p>
<p>Handler的removeCallbacks实现原理其实就是把MessageQueue链表中的某些节点移除掉。具体实现参见链表移除某个节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android知识点总结]]></title>
        <id>https://kutear.github.io/post/2017-04-17-Android_Advanced</id>
        <link href="https://kutear.github.io/post/2017-04-17-Android_Advanced">
        </link>
        <updated>2017-04-17T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android">Android</h1>
<ul>
<li>
<p>Server启动方式 || IntentService原理--&gt;只能startServive(...)启动 20s-&gt;ANR</p>
</li>
<li>
<p>broadcasts分类(无序广播,有序广播,Sticky广播) 10s-&gt;ANR  自定义权限  LocalBroadcastManager原理</p>
</li>
<li>
<p>Activity 启动模式 || 周期 ||Task<br>
以下是当 Activity A 启动 Activity B 时一系列操作的发生顺序：<br>
Activity A 的 onPause方法执行。<br>
Activity B 的 onCreate、onStart和 onResume方法依次执行。<br>
然后，如果 Activity A 在屏幕上不再可见，则其 onStop方法执行。</p>
</li>
<li>
<p>状态保存(Activity||自定义View) onSaveInstanceState调用时机(onStop之前 用户主动关闭不触发)   【Loader???】</p>
</li>
<li>
<p>Handler机制</p>
</li>
<li>
<p>AsyncTask原理(WorkerRunnable ||  FutureTask)</p>
</li>
<li>
<p>SharedPreference多进程共享</p>
</li>
</ul>
<h1 id="java">Java</h1>
<ul>
<li>
<p>内存模型</p>
<ul>
<li>
<p>程序计数器(线程私有)</p>
<blockquote>
<p>程序计数器PC，当前线程所执行的字节码行号指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。</p>
</blockquote>
</li>
<li>
<p>Java虚拟机栈(线程私有)</p>
<blockquote>
<p>虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)执行的同时都会创建一个栈帧结构，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。</p>
</blockquote>
</li>
<li>
<p>本地方法栈</p>
<blockquote>
<p>本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。</p>
</blockquote>
</li>
<li>
<p>Java堆</p>
<blockquote>
<p>Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。</p>
</blockquote>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
</li>
<li>
<p>方法区</p>
<blockquote>
<p>方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。</p>
</blockquote>
<ul>
<li>持久代</li>
<li>运行时常量池
<blockquote>
<p>运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">共享数据区</th>
<th style="text-align:center">线程私有区</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方法区(包括常量区)</td>
<td style="text-align:center">程序计数器</td>
</tr>
<tr>
<td style="text-align:center">Java堆[存放对象和数组]</td>
<td style="text-align:center">Java虚拟机栈</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">本地方法栈</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>线程同步问题</p>
<ul>
<li>synchronized</li>
<li>volatile</li>
<li>并发包</li>
</ul>
</li>
<li>
<p>GC</p>
<ul>
<li>判定方法(实施过程)
<ul>
<li>引用计数</li>
<li>引用链</li>
</ul>
</li>
<li>回收方法(各自特点)
<ul>
<li>标记清除</li>
<li>标记整理</li>
<li>复制</li>
</ul>
</li>
<li>内存分配方式
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
</li>
<li>分类
<ul>
<li>Minor GC</li>
<li>Major GC</li>
<li>Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React和ReactNative基础]]></title>
        <id>https://kutear.github.io/post/2017-04-17-React_React-Native_Base</id>
        <link href="https://kutear.github.io/post/2017-04-17-React_React-Native_Base">
        </link>
        <updated>2017-04-17T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>React-Router</p>
<pre><code class="language-javascript">&lt;Router&gt;
    &lt;Route path=&quot;/&quot; component={App}&gt;
      {/*http://host/*/}
      &lt;IndexRoute component={Dashboard} /&gt;
      {/*http://host/#//about*/}
      &lt;Route path=&quot;about&quot; component={About} /&gt;
      {/*http://host/#/inbox */}
      &lt;Route path=&quot;inbox&quot; component={Inbox}&gt;
        {/*http://host/#/inbox/message/id */}
        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;
        {/*http://host/#/messages/id */}
        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;
        {/*重定向*/}
        &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;
      &lt;/Route&gt;
    &lt;/Route&gt;
 &lt;/Router&gt;
</code></pre>
</li>
<li>
<p>Redux</p>
<ul>
<li>
<p>Action</p>
<p>是普通的对象，可以通过具体的函数(Action Creator)来返回</p>
</li>
<li>
<p>Reducer</p>
<p>通过Action返回state,在React中实际就是重置组件的state</p>
<p>多个reducer可以通过函数<code>combineReducer({reducer1,reducer2})</code>绑定。</p>
<pre><code class="language-javascript">const todoApp = combineReducers({
  todos,
  visibilityFilter
})
</code></pre>
</li>
<li>
<p>Store</p>
<pre><code class="language-javascript">const store = createStore(reducer)

//使用
render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
</li>
</ul>
</li>
<li>
<p>React-Redux</p>
<ul>
<li>
<p>函数<code>connect()</code>的使用。</p>
<pre><code class="language-javascript">const newComponent = connect(
  /*映射state到component的props*/
  stateToComponentsProps,
  /*component触发外部state变化的action*/
  mapDispatchToProps
)(Component)
</code></pre>
</li>
<li>
<p>Provider</p>
<pre><code class="language-javascript">&lt;Provider store={store}&gt;
    {Route}
&lt;/Provider&gt;
</code></pre>
</li>
<li>
<p>store</p>
<pre><code class="language-javascript">
</code></pre>
</li>
</ul>
</li>
<li>
<p>Navigator</p>
</li>
</ul>
<pre><code class="language-javascript">render(){
    let defaultName = 'FirstPageComponent';
    let defaultComponent = GFirst; //第一个显示的组件
    return(
          &lt;Navigator
              initialRoute = {{name:{defaultName},component:defaultComponent}}
              renderScene = {(router,navigator) =&gt; {
                  return &lt;router.component {...router.params} navigator={navigator}/&gt;
              }}
              configureScene={(router) =&gt; {
                  //页面启动动画
                  return Navigator.SceneConfigs.FloatFromBottom;
              }}
          /&gt;
      );
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android RecyclerView使用中的问题记录]]></title>
        <id>https://kutear.github.io/post/2017-04-13-Android_RecyclerView</id>
        <link href="https://kutear.github.io/post/2017-04-13-Android_RecyclerView">
        </link>
        <updated>2017-04-13T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="禁用recyclerview快速滑动之后默认的缓冲滑动效果">禁用RecyclerView快速滑动之后默认的缓冲滑动效果</h1>
<p>通过<code>google</code>一番，发现<code>RecyclerView</code>内部实现是使用了一个名为<code>ViewFlinger</code>的类，然而该类是<code>RecyclerView</code>的私有内部类，我们无法构建注入，所以就只能看看是在哪里进行了调用，通过代码搜索，找到函数</p>
<pre><code class="language-java">
	/**
     * Begin a standard fling with an initial velocity along each axis in pixels per second.
     * If the velocity given is below the system-defined minimum this method will return false
     * and no fling will occur.
     *
     * @param velocityX Initial horizontal velocity in pixels per second
     * @param velocityY Initial vertical velocity in pixels per second
     * @return true if the fling was started, false if the velocity was too low to fling or
     * LayoutManager does not support scrolling in the axis fling is issued.
     *
     * @see LayoutManager#canScrollVertically()
     * @see LayoutManager#canScrollHorizontally()
     */
    @Override
    public boolean fling(int velocityX, int velocityY) {
         ...
    }
</code></pre>
<p>根据注释部分的说明，传入x和y方向的速度，返回<code>true</code>表示开始猛滑，否则放弃猛滑。所以我们只要该函数一直返回<code>false</code>即可</p>
<h1 id="关于自定义layoutmanager">关于自定义LayoutManager</h1>
]]></content>
    </entry>
</feed>