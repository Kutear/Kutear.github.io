<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.kutear.com</id>
    <title>KuTear技术之旅</title>
    <updated>2024-03-12T13:03:34.990Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.kutear.com"/>
    <link rel="self" href="https://www.kutear.com/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://www.kutear.com/images/avatar.png</logo>
    <icon>https://www.kutear.com/favicon.ico</icon>
    <rights>All rights reserved 2024, KuTear技术之旅</rights>
    <entry>
        <title type="html"><![CDATA[Java 枚举]]></title>
        <id>https://www.kutear.com/post/java-mei-ju/</id>
        <link href="https://www.kutear.com/post/java-mei-ju/">
        </link>
        <updated>2024-03-12T12:51:05.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>默认枚举继承至Enum类,由于<code>Java</code>的单一继承机制,所以不能在继承至别的类.</li>
<li>枚举中的元素实质为类的类部静态常量域. <code>java public class EnumTest { enum Test { TEST_1(&quot;1&quot;), TEST_2(&quot;2&quot;); private String descript; Test(String descript) { this.descript = descript; } } }</code> 该枚举通过反编译查看其内部(<code>javap EnumTest$Test.class</code>),另外,枚举类是<code>final</code>,不会有子类 <code>java Compiled from &quot;EnumTest.java&quot; final class EnumTest$Test extends java.lang.Enum&lt;EnumTest$Test&gt; { public static final EnumTest$Test TEST_1; public static final EnumTest$Test TEST_2; public static EnumTest$Test[] values(); public static EnumTest$Test valueOf(java.lang.String); static {}; }</code></li>
<li>对于其构造函数,由于不允许用户自行实例化,构造器为<code>private</code>和<code>public</code>都是一样的.</li>
<li>静态导入,如上面的例子.再别的地使用可以使用静态导入 <code>java import static EnumTest.Test.*</code></li>
<li><code>Java</code>的<code>switch</code>子句支持的类型</li>
</ol>
<p>在Java7中引入的<code>String</code>本质上也是使用<code>int</code>来做判断的(<code>hashCode()</code>和<code>equals()</code>)<br>
- short(Short)<br>
- char(Charactor)<br>
- byte(Byte)<br>
- int(Integer)<br>
- String<br>
- enum<br>
6. 枚举的<code>values()</code>静态函数是由编译器写入.向上转型为<code>Enum</code>后丢失.但可以通过<code>Class</code>的<code>getEnumContants()</code>获取到枚举元素.<br>
7. 枚举实现抽象方法 <code>java enum FontConstant{ Blod{ @Override void show() { //TODO } }, Italilc{ @Override void show() { //TODO } }, Plain{ @Override void show() { //TODO } }; abstract void show(); }</code><br>
8. <code>EnumSet</code>和<code>EnumMap</code>的使用</p>
<p>由此可以看见,<code>EnumSet</code>的顺序是与<code>enum</code>的声明有关,并且只能添加不重复的对象<br>
- EnumSet<br>
内部的数据的顺序与<code>add(...)</code>时的顺序没有关系,而是与<code>enum</code>中声明的顺序一致,</p>
<pre><code>```java
public static void showEnumSet(){      EnumSet&lt;FontConstant&gt; enumSet = EnumSet.noneOf(FontConstant.class);      enumSet.add(FontConstant.Blod);      enumSet.add(FontConstant.Plain);      enumSet.add(FontConstant.Italilc);      enumSet.add(FontConstant.Blod);      for(Iterator&lt;FontConstant&gt; iter = enumSet.iterator(); iter.hasNext();){          System.out.println(iter.next());      }}
```

输出: &gt; Blod Italilc Plain

- EnumMap`EnumMap`与`EnumSet`的顺序是一样的.
</code></pre>
<ol start="9">
<li>
<p>枚举责任链</p>
<p>实现依赖与枚举的顺序</p>
<pre><code class="language-java">enum Handler {     HANDLER_1 {         @Override         boolean handler(Action action) {             return action.action == 1;         }     },     HANDLER_2 {         @Override         boolean handler(Action action) {             return action.action == 2;         }     };     abstract boolean handler(Action action);}public static class Action{     int action;     public Action(int action) {         this.action = action;     }}public static void handler(Action action) {     for (Handler handler : Handler.values()) {         if (handler.handler(action)) {             System.out.println(handler.name() + &quot; Handle This Action&quot;);             return;         }     }     System.out.println(&quot;No One Can Handle&quot;);}public static void main(String[] args) {     Action a1 = new Action(1);     handler(a1);     Action a2 = new Action(2);     handler(a2);     Action a3 = new Action(3);     handler(a3);}
</code></pre>
<p>输出 &gt; HANDLER_1 Handle This Action HANDLER_2 Handle This Action No One Can Handle</p>
</li>
<li>
<p>枚举状态机</p>
<p>1个事件的完成要经过A-&gt;B-&gt;C-&gt;D四个状态,</p>
<pre><code class="language-java">public void process(Status status){  switch(status.getStatus){    case A:       status.setStatus(B);       break;    case B:       status.setStatus(C);       break;    ...  }}
</code></pre>
<p>这是使用<code>(if/else)/switch</code>实现,我们还可以使用<code>enum</code>来实现</p>
<pre><code class="language-java">enum Status {    A {        @Override        void process(Product pro) {            pro.status = B;        }    },    B {        @Override        void process(Product pro) {            System.out.println(&quot;OK&quot;);            pro.status = C;          //reset        }    },    ...    abstract void process(Product pro);}public static class Product{    private Status status = Status.A;    public void make(){        status.process(this);    }}public static void main(String[] args) {    Product product = new Product();    for (int i = 0; i &lt; 10; i++) {        System.out.println(product.status.name());        product.make();    }}
</code></pre>
</li>
<li>
<p>枚举多路分发<br>
根据对象的类型而对方法进行的选择,就是分派(Dispatch)。</p>
</li>
</ol>
<ul>
<li>
<p>静态分派(编译时) <code>java static class A {} static class B extends A {} static class C extends A {} public static void print(A obj){ System.out.println(&quot;A&quot;); } public static void print(B obj){ System.out.println(&quot;B&quot;); } public static void print(C obj){ System.out.println(&quot;C&quot;); } public static void main(String[] args) { A a = new A(); print(a); A b = new B(); print(b); A c = new C(); print(c); }</code> 输出 &gt; A &gt; A &gt; A</p>
<ul>
<li>
<p>动态分派(运行时)</p>
<pre><code class="language-java">static class A {    public void print(){        System.out.println(&quot;A&quot;);    }}static class B extends A {    @Override    public void print() {        System.out.println(&quot;B&quot;);    }}static class C extends A {    @Override    public void print() {        System.out.println(&quot;C&quot;);    }}public static void main(String[] args) {    A a = new A();    a.print();    A b = new B();    b.print();    A c = new C();    c.print();}
</code></pre>
<p>输出 &gt;A &gt;B &gt;C</p>
</li>
</ul>
</li>
<li>
<p>两路分发</p>
<pre><code class="language-java"> public enum Outcome { WIN, LOSE, DRAW } ///:~ interface Item {       Outcome compete(Item it);       Outcome eval(Paper p);       Outcome eval(Scissors s);       Outcome eval(Rock r); } class Paper implements Item {       public Outcome compete(Item it) {           return it.eval(this);       }       public Outcome eval(Paper p) {           return DRAW;       }       public Outcome eval(Scissors s) {           return WIN;       }       public Outcome eval(Rock r) {           return LOSE;       }       public String toString() {           return &quot;Paper&quot;;       }    }     class Scissors implements Item {         public Outcome compete(Item it) {             return it.eval(this);         }         public Outcome eval(Paper p) {             return LOSE;         }         public Outcome eval(Scissors s) {             return DRAW;         }         public Outcome eval(Rock r) {             return WIN;         }         public String toString() {             return &quot;Scissors&quot;;         }     }     class Rock implements Item {         public Outcome compete(Item it) {             return it.eval(this);         }         public Outcome eval(Paper p) {             return WIN;         }         public Outcome eval(Scissors s) {             return LOSE;         }         public Outcome eval(Rock r) {             return DRAW;         }         public String toString() {             return &quot;Rock&quot;;         } } public class RoShamBo1 {     static final int SIZE = 20;     private static Random rand = new Random(47);     public static Item newItem() {         switch (rand.nextInt(3)) {         default:         case 0:             return new Scissors();         case 1:             return new Paper();         case 2:             return new Rock();         }     }     public static void match(Item a, Item b) {         //在这里两个参数a和b的类型都不确切,         //通过动态调用a.compete()可以调到真实的a的compete(),         //而在具体类型的compete通过同样的方式,获取到b的确切类型         //在更具重载的方法调用到了具体的方法         System.out.println(a + &quot; vs. &quot; + b + &quot;: &quot; + a.compete(b));     }     public static void main(String[] args) {         for (int i = 0; i &lt; SIZE; i++)             match(newItem(), newItem());     } }
</code></pre>
<blockquote>
<p>多路分发就是指在调用a.plus(b)，a和b都不知道确切类型，也能让他们正常交互。 如果想使用两路分发，那么必须有两个方法调用，第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知类型。要利用多路分发，程序员必须为每一个类型提供给一个实际的方法调用。一般而言，程序员需要设定好某种配置，以便一个方法调用能够引出更多的方法调用，从而能在这个过程中处理多个类型。</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android XML解析]]></title>
        <id>https://www.kutear.com/post/android-xml-jie-xi/</id>
        <link href="https://www.kutear.com/post/android-xml-jie-xi/">
        </link>
        <updated>2019-06-12T12:47:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="2016-10-09-android_xml_parser">2016-10-09-Android_Xml_Parser</h1>
<h1 id="view">View</h1>
<p>对于<code>View</code>我们常见的使用就是两种，一种是<code>setContent(int)</code>，另一种为<code>LayoutInflater.inflate()</code>,其本质都是一样的。皆为<code>LayoutInflater.inflate()</code>,我们分析一下这里的具体实现。</p>
<pre><code class="language-java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    final XmlResourceParser parser = res.getLayout(resource); //根据xml返回一个解析器    try {        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}
</code></pre>
<p>接着就是函数<code>inflate()</code>.</p>
<pre><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {    synchronized (mConstructorArgs) {      final String name = parser.getName();      if (TAG_MERGE.equals(name)) { //如果是&lt;merge /&gt;标签          if (root == null || !attachToRoot) {              throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;                      + &quot;ViewGroup root and attachToRoot=true&quot;);          }          //内部也是通过函数createViewFromTag()生成View,并调用rInflateChildren()递归解析         rInflate(parser, root, inflaterContext, attrs, false);    } else {        // Temp is the root view that was found in the xml        //根据当前标签tag创建View        final View temp = createViewFromTag(root, name, inflaterContext, attrs);        ViewGroup.LayoutParams params = null;        if (root != null) {          //获取xml中的属性，如宽高，待为view设置layoutparams            params = root.generateLayoutParams(attrs);            if (!attachToRoot) {                // Set the layout params for temp if we are not                // attaching. (If we are, we use addView, below)                temp.setLayoutParams(params);            }        }        // Inflate all children under temp against its context.        //把当前解析的view作为parent,继续递归解析她的child View        rInflateChildren(parser, temp, attrs, true);        // We are supposed to attach all the views we found (int temp)        // to root. Do that now.        if (root != null &amp;&amp; attachToRoot) {          //最后把当前解析的view添加到他的parent中            root.addView(temp, params);        }        // Decide whether to return the root that was passed in or the        // top view found in xml.        if (root == null || !attachToRoot) {            result = temp;        }      }      return result;    }}
</code></pre>
<p>上面的函数非常容易理解，我们现在要看的函数就是<code>createViewFromTag()</code></p>
<pre><code class="language-java">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,        boolean ignoreThemeAttr) {    if (name.equals(&quot;view&quot;)) {        name = attrs.getAttributeValue(null, &quot;class&quot;);    }    //原来xml还可以写成    //&lt;view class=&quot;TextView&quot; ...&gt;的形式    //&lt;blink&gt;标签  实现闪烁的如&lt;blink&gt;&lt;TextView text=&quot;AA&quot; ...&gt;&lt;/blink&gt; 那么AA会闪烁    if (name.equals(TAG_1995)) {        // Let's party like it's 1995!        return new BlinkLayout(context, attrs);    }    try {        View view;        ...        //这里有一些Factory创建方式，但是他的逻辑和下面一样，不多说        ...        if (view == null) {            final Object lastContext = mConstructorArgs[0];            mConstructorArgs[0] = context;            try {                if (-1 == name.indexOf('.')) {                    view = onCreateView(parent, name, attrs); //不含. 一定是系统的View,如TextView                } else {                    view = createView(name, null, attrs);  //非系统VIew 如支持库的View,自定义的View                }            } finally {                mConstructorArgs[0] = lastContext;            }        }        return view;    } catch (InflateException e) {      ...    }}
</code></pre>
<p>通过源码，我们发现<code>onCreateView(..)</code>其实是调用<code>createView(name, &quot;android.view.&quot;, attrs)</code>,只是人为的加上View的前缀。</p>
<pre><code class="language-java">public final View createView(String name, String prefix, AttributeSet attrs)        throws ClassNotFoundException, InflateException {    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);  //构造函数缓存    Class&lt;? extends View&gt; clazz = null;    try {        if (constructor == null) {            // Class not found in the cache, see if it's real, and try to add it            clazz = mContext.getClassLoader().loadClass(                    prefix != null ? (prefix + name) : name).asSubclass(View.class);            ...            //    static final Class&lt;?&gt;[] mConstructorSignature = new Class[] {            //                                Context.class, AttributeSet.class};            constructor = clazz.getConstructor(mConstructorSignature);//这里我们就可以看到为什么View在xml实例时调用两个参数的构造函数            constructor.setAccessible(true);            sConstructorMap.put(name, constructor);        } else {            // If we have a filter, apply it to cached constructor            if (mFilter != null) {                // Have we seen this name before?                Boolean allowedState = mFilterMap.get(name);                if (allowedState == null) {                    // New class -- remember whether it is allowed                    clazz = mContext.getClassLoader().loadClass(                            prefix != null ? (prefix + name) : name).asSubclass(View.class);                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);                    mFilterMap.put(name, allowed);                    if (!allowed) {                        failNotAllowed(name, prefix, attrs);                    }                } else if (allowedState.equals(Boolean.FALSE)) {                    failNotAllowed(name, prefix, attrs);                }            }        }        Object[] args = mConstructorArgs;        args[1] = attrs;        final View view = constructor.newInstance(args); //实例化View对象        if (view instanceof ViewStub) {            // Use the same context when inflating ViewStub later.            final ViewStub viewStub = (ViewStub) view;            //对于ViewStub,现在还没解析其内部结构，待调用函数inflate()时才解析替换为内部的View。            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));        }        return view;    } catch (NoSuchMethodException e) {      ...    }}
</code></pre>
<p>到此View的解析就算完了。</p>
<h1 id="drawable">Drawable</h1>
<p>这里以Background为例说明，在View的构造哈数中存在这样一段代码</p>
<pre><code class="language-java">//View.javafinal TypedArray a = context.obtainStyledAttributes(                attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);int attr = a.getIndex(i);switch (attr) {    case com.android.internal.R.styleable.View_background:        background = a.getDrawable(attr);        break;    case ..}
</code></pre>
<pre><code class="language-java">//TypedArray.java@Nullablepublic Drawable getDrawable(int index) {  ...  return mResources.loadDrawable(value, value.resourceId, mTheme);}
</code></pre>
<p>在<code>loadDrawable()</code>当中，做了一些判断，比如当前要的<code>Drawable</code>是否已经加载过了，即判断是否已经在缓存中，如果在就不需要从xml中加载，反之就需要加载，并保存在缓存中。而加载就是调用函数<code>loadDrawableForCookie()</code>,下面看看具体的实现。</p>
<pre><code class="language-java">private Drawable loadDrawableForCookie(TypedValue value, int id, Theme theme) {    if (value.string == null) {        throw new NotFoundException(&quot;Resource \&quot;&quot; + getResourceName(id) + &quot;\&quot; (&quot;                + Integer.toHexString(id) + &quot;) is not a Drawable (color or path): &quot; + value);    }    final String file = value.string.toString(); //这里是文件的路径 如res/drawable/xxx.png    final Drawable dr;    try {        if (file.endsWith(&quot;.xml&quot;)) {            final XmlResourceParser rp = loadXmlResourceParser(                    file, id, value.assetCookie, &quot;drawable&quot;);            dr = Drawable.createFromXml(this, rp, theme);            rp.close();        } else {            final InputStream is = mAssets.openNonAsset(                    value.assetCookie, file, AssetManager.ACCESS_STREAMING);            dr = Drawable.createFromResourceStream(this, value, is, file, null);            is.close();        }    } catch (Exception e) {    }    return dr;}
</code></pre>
<p>很容易看到，这里以xml结尾的文件和其他如png结尾的文件做了分别处理，先看看简单的普通的图片格式，也就是<code>else</code>中的代码。可以看见是很简单的实现，就是把图片转换为数据流，在通过数据流构建Drawable对象。重点看看xml类型Drawable的生成吧。跟入进去，我们发现有个特别的函数<code>createFromXmlInner()</code>，为什么说特别？因为它就是创建具体<code>Drawable</code>的函数。</p>
<pre><code class="language-java">public static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs,        Theme theme) throws XmlPullParserException, IOException {    final Drawable drawable;    final String name = parser.getName();    switch (name) {        case &quot;selector&quot;:            drawable = new StateListDrawable();            break;        case &quot;animated-selector&quot;:            drawable = new AnimatedStateListDrawable();            break;        case &quot;level-list&quot;:            drawable = new LevelListDrawable();            break;        case &quot;layer-list&quot;:            drawable = new LayerDrawable();            break;        case &quot;transition&quot;:            drawable = new TransitionDrawable();            break;        case &quot;ripple&quot;:            drawable = new RippleDrawable();            break;        case &quot;color&quot;:            drawable = new ColorDrawable();            break;        case &quot;shape&quot;:            drawable = new GradientDrawable();            break;        case &quot;vector&quot;:            drawable = new VectorDrawable();            break;        case &quot;animated-vector&quot;:            drawable = new AnimatedVectorDrawable();            break;        case &quot;scale&quot;:            drawable = new ScaleDrawable();            break;        case &quot;clip&quot;:            drawable = new ClipDrawable();            break;        case &quot;rotate&quot;:            drawable = new RotateDrawable();            break;        case &quot;animated-rotate&quot;:            drawable = new AnimatedRotateDrawable();            break;        case &quot;animation-list&quot;:            drawable = new AnimationDrawable();            break;        case &quot;inset&quot;:            drawable = new InsetDrawable();            break;        case &quot;bitmap&quot;:            drawable = new BitmapDrawable();            break;        case &quot;nine-patch&quot;:            drawable = new NinePatchDrawable();            break;        default:            throw new XmlPullParserException(parser.getPositionDescription() +                    &quot;: invalid drawable tag &quot; + name);    }    drawable.inflate(r, parser, attrs, theme);    return drawable;}
</code></pre>
<p>前面的<code>switch</code>就是简单的根据标签tag创建具体的对象，最后调用<code>drawable.inflate()</code>来配置具体的参数。这里我们一帧动画<code>AnimationDrawable</code>来说明。</p>
<pre><code class="language-java">@Overridepublic void inflate(Resources r, XmlPullParser parser, AttributeSet attrs, Theme theme)        throws XmlPullParserException, IOException {    final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.AnimationDrawable);    super.inflateWithAttributes(r, parser, a, R.styleable.AnimationDrawable_visible);    updateStateFromTypedArray(a);    a.recycle();    inflateChildElements(r, parser, attrs, theme);}private void inflateChildElements(Resources r, XmlPullParser parser, AttributeSet attrs,        Theme theme) throws XmlPullParserException, IOException {    int type;    final int innerDepth = parser.getDepth()+1;    int depth;    //循环获取每一帧动画信息    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT            &amp;&amp; ((depth = parser.getDepth()) &gt;= innerDepth || type != XmlPullParser.END_TAG)) {        if (type != XmlPullParser.START_TAG) {            continue;        }        if (depth &gt; innerDepth || !parser.getName().equals(&quot;item&quot;)) {            continue;        }        //取得每个名为item的tag结点        final TypedArray a = obtainAttributes(r, theme, attrs,                R.styleable.AnimationDrawableItem);        final int duration = a.getInt(R.styleable.AnimationDrawableItem_duration, -1);        if (duration &lt; 0) {            throw new XmlPullParserException(parser.getPositionDescription()                    + &quot;: &lt;item&gt; tag requires a 'duration' attribute&quot;);        }        Drawable dr = a.getDrawable(R.styleable.AnimationDrawableItem_drawable); //按照解析png的方式解析        a.recycle();        if (dr == null) {            while ((type=parser.next()) == XmlPullParser.TEXT) {                // Empty            }            if (type != XmlPullParser.START_TAG) {                throw new XmlPullParserException(parser.getPositionDescription()                        + &quot;: &lt;item&gt; tag requires a 'drawable' attribute or child tag&quot;                        + &quot; defining a drawable&quot;);            }            dr = Drawable.createFromXmlInner(r, parser, attrs, theme);  //item内部再嵌xml类型的Drawable        }        mAnimationState.addFrame(dr, duration); //添加到存储每一帧的容器，带播放时使用        if (dr != null) {            dr.setCallback(this);        }    }}
</code></pre>
<p>对于<code>Drawable</code>的解析大体就这些。 # Animation 我们知道，Android动画大体分为三类，帧动画，View 动画，和属性动画。帧动画在上面Drawable已经说过了。而View动画和属性动画基本一样的解析。下面以属性动画为例看一下。我们选择从函数<code>loadAnimator(Context context, @AnimatorRes int id)</code>入手。</p>
<pre><code class="language-java">public static Animator loadAnimator(Resources resources, Theme theme, int id,            float pathErrorScale) throws NotFoundException {        final ConfigurationBoundResourceCache&lt;Animator&gt; animatorCache = resources                .getAnimatorCache();        Animator animator = animatorCache.getInstance(id, theme); //优先缓存读取        if (animator != null) {            return animator;        } else if (DBG_ANIMATOR_INFLATER) {            Log.d(TAG, &quot;cache miss for animator &quot; + resources.getResourceName(id));        }        //缓存中不存在，需要解析        XmlResourceParser parser = null;        try {            parser = resources.getAnimation(id);            animator = createAnimatorFromXml(resources, theme, parser, pathErrorScale);//动画的创建            if (animator != null) {                animator.appendChangingConfigurations(getChangingConfigs(resources, id));                final ConstantState&lt;Animator&gt; constantState = animator.createConstantState();                if (constantState != null) {                    if (DBG_ANIMATOR_INFLATER) {                        Log.d(TAG, &quot;caching animator for res &quot; + resources.getResourceName(id));                    }                    animatorCache.put(id, theme, constantState);                    // create a new animator so that cached version is never used by the user                    // 这里的注释说明每次从缓存中读取的cache其实也是通过这种方式创建的。                    animator = constantState.newInstance(resources, theme);                }            }            return animator;        } catch (XmlPullParserException ex) {            ...        } finally {            if (parser != null) parser.close();        }    }
</code></pre>
<p>毕竟这不是我们这里需要主要关注的，下面我们看看创建的函数<code>createAnimatorFromXml()</code>.</p>
<pre><code class="language-java">private static Animator createAnimatorFromXml(Resources res, Theme theme, XmlPullParser parser,        AttributeSet attrs, AnimatorSet parent, int sequenceOrdering, float pixelSize)        throws XmlPullParserException, IOException {    Animator anim = null;    ArrayList&lt;Animator&gt; childAnims = null;    // Make sure we are on a start tag.    int type;    int depth = parser.getDepth();    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth)            &amp;&amp; type != XmlPullParser.END_DOCUMENT) {        if (type != XmlPullParser.START_TAG) {            continue;        }        String name = parser.getName();        boolean gotValues = false;        if (name.equals(&quot;objectAnimator&quot;)) {  //生成objectAnimator            anim = loadObjectAnimator(res, theme, attrs, pixelSize);        } else if (name.equals(&quot;animator&quot;)) { //ValueAnimator            anim = loadAnimator(res, theme, attrs, null, pixelSize);  //递归过程        } else if (name.equals(&quot;set&quot;)) {  //AnimatorSet            //我们知道，AnimatorSet是个容器，这里的逻辑就是把它作为parent,在递归解析子元素            anim = new AnimatorSet();            TypedArray a;            if (theme != null) {                a = theme.obtainStyledAttributes(attrs, R.styleable.AnimatorSet, 0, 0);            } else {                a = res.obtainAttributes(attrs, R.styleable.AnimatorSet);            }            anim.appendChangingConfigurations(a.getChangingConfigurations());            int ordering = a.getInt(R.styleable.AnimatorSet_ordering, TOGETHER);            createAnimatorFromXml(res, theme, parser, attrs, (AnimatorSet) anim, ordering,                    pixelSize); //递归调用            a.recycle();        } else if (name.equals(&quot;propertyValuesHolder&quot;)) {  //这里面还会解析keyframe标签            PropertyValuesHolder[] values = loadValues(res, theme, parser,                    Xml.asAttributeSet(parser));            if (values != null &amp;&amp; anim != null &amp;&amp; (anim instanceof ValueAnimator)) {                ((ValueAnimator) anim).setValues(values);            }            gotValues = true;        } else {            throw new RuntimeException(&quot;Unknown animator name: &quot; + parser.getName());        }        if (parent != null &amp;&amp; !gotValues) {            if (childAnims == null) {                childAnims = new ArrayList&lt;Animator&gt;();            }            childAnims.add(anim);        }    }    //生成完毕，考虑添加到Parent    if (parent != null &amp;&amp; childAnims != null) {        Animator[] animsArray = new Animator[childAnims.size()];        int index = 0;        for (Animator a : childAnims) {            animsArray[index++] = a;        }        if (sequenceOrdering == TOGETHER) {            parent.playTogether(animsArray);        } else {            parent.playSequentially(animsArray);        }    }    return anim;}
</code></pre>
<p>有点抽象，下面我们先写一个小例子看看动画的所有结构。</p>
<pre><code class="language-xml">&lt;set android:ordering=&quot;sequentially&quot;&gt;      &lt;animator            android:duration=&quot;1000&quot;            android:repeatCount=&quot;1&quot;            android:repeatMode=&quot;reverse&quot;&gt;      &lt;propertyValuesHolder&gt;          &lt;keyframe android:fraction=&quot;0&quot; android:value=&quot;1&quot;/&gt;          &lt;keyframe android:fraction=&quot;.2&quot; android:value=&quot;.4&quot;/&gt;          &lt;keyframe android:fraction=&quot;1&quot; android:value=&quot;0&quot;/&gt;      &lt;/propertyValuesHolder&gt;    &lt;/animator&gt;    &lt;objectAnimator        android:duration=&quot;500&quot;        android:valueTo=&quot;1f&quot;&gt;          &lt;propertyValuesHolder android:propertyName=&quot;x&quot; &gt;                &lt;keyframe android:fraction=&quot;0&quot; android:value=&quot;800&quot; /&gt;                &lt;keyframe android:fraction=&quot;.2&quot;                          android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;                          android:value=&quot;1000&quot; /&gt;                &lt;keyframe android:fraction=&quot;1&quot;                          android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;                          android:value=&quot;400&quot; /&gt;          &lt;/propertyValuesHolder&gt;          &lt;propertyValuesHolder android:propertyName=&quot;y&quot; &gt;                &lt;keyframe/&gt;                &lt;keyframe android:fraction=&quot;.2&quot;                          android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;                          android:value=&quot;300&quot;/&gt;                &lt;keyframe android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;                          android:value=&quot;1000&quot; /&gt;          &lt;/propertyValuesHolder&gt;      &lt;/objectAnimator&gt;&lt;/set&gt;
</code></pre>
<p>我们接下来以<code>&lt;propertyValuesHolder/&gt;</code>的解析为例来说明。</p>
<pre><code class="language-java">private static PropertyValuesHolder[] loadValues(Resources res, Theme theme,            XmlPullParser parser, AttributeSet attrs) throws XmlPullParserException, IOException {        ArrayList&lt;PropertyValuesHolder&gt; values = null;        int type;        while ((type = parser.getEventType()) != XmlPullParser.END_TAG &amp;&amp;                type != XmlPullParser.END_DOCUMENT) {            if (type != XmlPullParser.START_TAG) {                parser.next();                continue;            }            String name = parser.getName();            if (name.equals(&quot;propertyValuesHolder&quot;)) {                TypedArray a;                if (theme != null) {                    a = theme.obtainStyledAttributes(attrs, R.styleable.PropertyValuesHolder, 0, 0);                } else {                    a = res.obtainAttributes(attrs, R.styleable.PropertyValuesHolder);                }                String propertyName = a.getString(R.styleable.PropertyValuesHolder_propertyName);                int valueType = a.getInt(R.styleable.PropertyValuesHolder_valueType,                        VALUE_TYPE_UNDEFINED);                PropertyValuesHolder pvh = loadPvh(res, theme, parser, propertyName, valueType);                if (pvh == null) {                    pvh = getPVH(a, valueType,                            R.styleable.PropertyValuesHolder_valueFrom,                            R.styleable.PropertyValuesHolder_valueTo, propertyName);                }                if (pvh != null) {                    if (values == null) {                        values = new ArrayList&lt;PropertyValuesHolder&gt;();                    }                    values.add(pvh);                }                a.recycle();            }            parser.next();        }        PropertyValuesHolder[] valuesArray = null;        if (values != null) {            int count = values.size();            valuesArray = new PropertyValuesHolder[count];            for (int i = 0; i &lt; count; ++i) {                valuesArray[i] = values.get(i);            }        }        return valuesArray;    }
</code></pre>
<p>上面代码没什么可说的，唯一要看的就是<code>PropertyValuesHolder</code>的创建函数<code>loadPvh()</code>。</p>
<pre><code class="language-java">private static PropertyValuesHolder loadPvh(Resources res, Theme theme, XmlPullParser parser,        String propertyName, int valueType)        throws XmlPullParserException, IOException {    PropertyValuesHolder value = null;    ArrayList&lt;Keyframe&gt; keyframes = null;    int type;    while ((type = parser.next()) != XmlPullParser.END_TAG &amp;&amp;            type != XmlPullParser.END_DOCUMENT) {        String name = parser.getName();        if (name.equals(&quot;keyframe&quot;)) {            if (valueType == VALUE_TYPE_UNDEFINED) {                valueType = inferValueTypeOfKeyframe(res, theme, Xml.asAttributeSet(parser));            }            //解析keyframe            Keyframe keyframe = loadKeyframe(res, theme, Xml.asAttributeSet(parser), valueType);            if (keyframe != null) {                if (keyframes == null) {                    keyframes = new ArrayList&lt;Keyframe&gt;();                }                keyframes.add(keyframe);            }            parser.next();        }    }    int count;    if (keyframes != null &amp;&amp; (count = keyframes.size()) &gt; 0) {        ...对keyframes的调整        value = PropertyValuesHolder.ofKeyframe(propertyName, keyframeArray); //设置keyframe        if (valueType == VALUE_TYPE_COLOR) {            value.setEvaluator(ArgbEvaluator.getInstance());//设置估值器        }    }    return value;}
</code></pre>
<p>卧槽，一层一层何时能到头。</p>
<pre><code class="language-java">private static Keyframe loadKeyframe(Resources res, Theme theme, AttributeSet attrs,        int valueType)        throws XmlPullParserException, IOException {    TypedArray a;    if (theme != null) {        a = theme.obtainStyledAttributes(attrs, R.styleable.Keyframe, 0, 0);    } else {        a = res.obtainAttributes(attrs, R.styleable.Keyframe);    }    Keyframe keyframe = null;    float fraction = a.getFloat(R.styleable.Keyframe_fraction, -1);    TypedValue keyframeValue = a.peekValue(R.styleable.Keyframe_value);    boolean hasValue = (keyframeValue != null);    if (valueType == VALUE_TYPE_UNDEFINED) {        // When no value type is provided, check whether it's a color type first.        // If not, fall back to default value type (i.e. float type).        if (hasValue &amp;&amp; isColorType(keyframeValue.type)) {            valueType = VALUE_TYPE_COLOR;        } else {            valueType = VALUE_TYPE_FLOAT;        }    }    if (hasValue) {        switch (valueType) {            case VALUE_TYPE_FLOAT:                float value = a.getFloat(R.styleable.Keyframe_value, 0);                keyframe = Keyframe.ofFloat(fraction, value);                break;            case VALUE_TYPE_COLOR:            case VALUE_TYPE_INT:                int intValue = a.getInt(R.styleable.Keyframe_value, 0);                keyframe = Keyframe.ofInt(fraction, intValue);                break;        }    } else {        keyframe = (valueType == VALUE_TYPE_FLOAT) ? Keyframe.ofFloat(fraction) :                Keyframe.ofInt(fraction);    }    final int resID = a.getResourceId(R.styleable.Keyframe_interpolator, 0);    if (resID &gt; 0) {        final Interpolator interpolator = AnimationUtils.loadInterpolator(res, theme, resID); //插值器，和View动画一致        keyframe.setInterpolator(interpolator);    }    a.recycle();    return keyframe;}
</code></pre>
<p>上面函数很简单，就是根据不同的type生成不同的keyframe,而type我们从上面知道是从TypedValue.type来判断的。TypedValue中持有很多的type声明</p>
<pre><code class="language-java">...public static final int TYPE_DIMENSION = 0x05;/** The &lt;var&gt;data&lt;/var&gt; field holds a complex number encoding a fraction *  of a container. */public static final int TYPE_FRACTION = 0x06;...
</code></pre>
<p>好了，到这里就算分析完了,里面有很多代码现在还是不太清楚具体的逻辑。但是我们流程还是算清楚的了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://www.kutear.com/post/hello-gridea/</id>
        <link href="https://www.kutear.com/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="https://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android SparseArray]]></title>
        <id>https://www.kutear.com/post/android-sparsearray/</id>
        <link href="https://www.kutear.com/post/android-sparsearray/">
        </link>
        <updated>2018-03-12T12:50:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="put">Put</h2>
<pre><code class="language-java">//SparseArray.javapublic void put(int key, E value) {       //二分查找,SparseArray是由小到大排序的       //找到是返回该key对应的index       //没找到时该key在这时应该放置index的补运算的结果(负数)        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);        if (i &gt;= 0) {  //找到            mValues[i] = value;        } else { //没找到            i = ~i;  //求补,得到该放置的位置.            if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {  //该放置的位置没有数据在还没有元素/1个元素或者有进行删除数据的时候出现                mKeys[i] = key;                mValues[i] = value;                return;            }            if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {                gc(); //数据紧凑                // Search again because indices may have changed.                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);            }            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);            mSize++;        }}
</code></pre>
<pre><code class="language-java">//SparseArray.java//使数据紧凑(数据集中在数组前端)private void gc() {        // Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);        int n = mSize;        int o = 0;        int[] keys = mKeys;        Object[] values = mValues;        for (int i = 0; i &lt; n; i++) {            Object val = values[i];            if (val != DELETED) {                if (i != o) {                    keys[o] = keys[i];                    values[o] = val;                    values[i] = null;                }                o++;            }        }        mGarbage = false;        mSize = o;        // Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);}
</code></pre>
<pre><code class="language-java">//ContainerHelpers.java// This is Arrays.binarySearch(), but doesn't do any argument validation.//[不做参数范围检测]static int binarySearch(int[] array, int size, int value) {        int lo = 0;        int hi = size - 1;        while (lo &lt;= hi) {            final int mid = (lo + hi) &gt;&gt;&gt; 1;            final int midVal = array[mid];            if (midVal &lt; value) {                lo = mid + 1;            } else if (midVal &gt; value) {                hi = mid - 1;            } else {                return mid;  // value found            }        }        return ~lo;  // value not present}
</code></pre>
<pre><code class="language-java">//GrowingArrayUtils.javapublic static &lt;T&gt; T[] insert(T[] array, int currentSize, int index, T element) {        assert currentSize &lt;= array.length;        if (currentSize + 1 &lt;= array.length) {            //(T[] src, int srcPos, T[] dst, int dstPos, int length)            //也就是把array的index(包括自身)后的元素往后移动1个单位            System.arraycopy(array, index, array, index + 1, currentSize - index);            array[index] = element;            return array;        }        //数组容量不够,扩容        @SuppressWarnings(&quot;unchecked&quot;)        T[] newArray = ArrayUtils.newUnpaddedArray((Class&lt;T&gt;)array.getClass().getComponentType(),                growSize(currentSize));        //growSize(currentSize) ==&gt; return currentSize &lt;= 4 ? 8 : currentSize * 2;        System.arraycopy(array, 0, newArray, 0, index);        newArray[index] = element;        System.arraycopy(array, index, newArray, index + 1, array.length - index);        return newArray;}
</code></pre>
<h2 id="delete-remove">Delete &amp; Remove</h2>
<pre><code class="language-java">//SparseArray.javapublic void remove(int key) {        delete(key);}public void delete(int key) {        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);        if (i &gt;= 0) {            if (mValues[i] != DELETED) {                mValues[i] = DELETED;                mGarbage = true;                //在这里并没有把mSize减一和做数组紧缩操作，而是在要用的做，               //比如调getSize()就会做数组紧缩，这样才可以得到真正的size            }        }}
</code></pre>
<h2 id="append">Append</h2>
<pre><code class="language-java">//SparseArray.java//由于SparseArray几乎所有的操作都是基于二分查找算法,所以append的实现肯定不能//直接appendpublic void append(int key, E value) {        //如果值不够大,当然排不到最后,转为put        if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) {            put(key, value);            return;        }        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {            gc();        }        mKeys = GrowingArrayUtils.append(mKeys, mSize, key);        mValues = GrowingArrayUtils.append(mValues, mSize, value);        mSize++;}
</code></pre>
<pre><code class="language-java">//GrowingArrayUtils.javapublic static &lt;T&gt; T[] append(T[] array, int currentSize, T element) {        assert currentSize &lt;= array.length;        //申请新容量        if (currentSize + 1 &gt; array.length) {            @SuppressWarnings(&quot;unchecked&quot;)            T[] newArray = ArrayUtils.newUnpaddedArray(                    (Class&lt;T&gt;) array.getClass().getComponentType(), growSize(currentSize));            System.arraycopy(array, 0, newArray, 0, currentSize);            array = newArray;        }        array[currentSize] = element;        return array;}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[弹幕优化]]></title>
        <id>https://www.kutear.com/post/dan-mu-you-hua/</id>
        <link href="https://www.kutear.com/post/dan-mu-you-hua/">
        </link>
        <updated>2017-07-12T12:46:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>弹幕作为国内直播平台必不可少的功能之一，其性能的好坏直接影响用户观看视频的体验。企鹅电竞使用的是B站的弹幕组件(修改了排版的逻辑)，它的最后一次维护也是在两年前了，更重要的是随着电竞业务的发展，该组件不论是在功能还是性能方面都无法满足我们的业务需求，我们准备实现一套满足电竞业务的弹幕组件。</p>
<h1 id="实现">实现</h1>
<p>在开始介绍新的弹幕组件之前，我们先看一下B站弹幕组件的原理及问题。 B站弹幕支持</p>
<pre><code>View
</code></pre>
<p>,</p>
<pre><code>TextureView
</code></pre>
<p>,</p>
<pre><code>SurfaceView
</code></pre>
<p>三种方式进行绘制，其中</p>
<pre><code>TextureView
</code></pre>
<p>,</p>
<pre><code>SurfaceView
</code></pre>
<p>都是采用</p>
<pre><code>lockCanvas()
</code></pre>
<p>的方式，该方式本质都是向</p>
<pre><code>Surface
</code></pre>
<p>申请一块Buffer，再向Buffer写数据，该操作是软绘制，所以我们项目中实际使用的是基于</p>
<pre><code>View
</code></pre>
<p>的绘制方案。每次添加弹幕首先会复用一个大小合适(没有时创建)的Bitmap,使用异步线程利用CPU将弹幕内容绘制到Bitmap中，等到了上屏的时机利用</p>
<pre><code>View
</code></pre>
<p>的</p>
<pre><code>onDraw(...)
</code></pre>
<p>进行绘制，通常情况下这都是使用硬件绘制，那么这会存在什么问题呢？Android的View的硬件绘制的流程是在主线程构建Display List，然后在Render Thread进行指令合并与执行纹理上传渲染(OpenGL)，在大量弹幕的情况下会出现大量纹理上传，纹理上传过程中通常主线程会wait保证数据一致，这会导致主线线卡顿已经以及Render Thread绘制超时，另外弹幕占用的内存显存也是非常的大。为此我们希望可以优化卡顿，内存/显存的占用。 新弹幕组件采用一张Bitmap承载多条弹幕的方式，减少多Bitmap纹理上传的的次数，在OpenGL中渲染每一条弹幕的时候，在从纹理中扣取每条弹幕的位置信息(纹理坐标)进行渲染。要使用OpenGL我们考虑使用TextureView或是SurfaceView(GLSurfaceView)，由于业务中弹幕处于View的中间层，SurfaceView无法嵌入，所以使用的时候我们会使用TextureView(SurfaceView绘制也实现了)。由于一批弹幕生成的BItmap尺寸相对于单条弹幕大了很多，所以在做纹理上传的时候需要考虑非渲染线程异步执行。</p>
<p>!https://www.kutear.com/post-images/1584686473976.png</p>
<h1 id="优化">优化</h1>
<h2 id="动态弹幕的支持">动态弹幕的支持</h2>
<p>使用上面的方案我们可以很容易的完成所有静态弹幕的展示，但是业务需求中通常会出现一些高级弹幕，这种弹幕通常自身就带有动效(比如背景是张webp等动图)，这是如果还是走基于一张Bitmap的方案，就的将动图的每一帧预先绘制到Bitmap并需要自己控制显示的时机，这样操作过于复杂且扩展性不够，因此排除这个方案。我们采用最直接方式-支持View插入到弹幕系统中，这样我们不需要控制View的内容到底是怎样个动法，我们只关心他在整个弹幕系统中的位置，我们的排版逻辑依旧是可用的，我们只需要添加一种展示方式，为此我们将弹幕展示分为静态弹幕展示层与动态弹幕展示层。</p>
<h2 id="内存显存的占用">内存/显存的占用</h2>
<p>使用这个方案实现弹幕组件之后，FPS以及CPU的占用上面都优于B站弹幕库，但是在显存的占用上面却比B站弹幕多出一部分。</p>
<p>!https://www.kutear.com/post-images/1584672574953.png</p>
<p>主要多出来显存开销其实来源于TextureView自身环境的开销，TextureView运行会创建Surface,Surface有一个双缓冲或三缓冲的Buffer,他的大小和TextureView的大小以及Buffer的数量有关，可以使用</p>
<pre><code>adb shell dumpsys meminfo pkg
</code></pre>
<p>来进行查看(下图中的</p>
<pre><code>EGL mtrack
</code></pre>
<p>)，这个值初始化好之后就是固定的，对于我们业务侧很难去减少这块显存的占用，所以我们的优化主要都集中在我们自己的纹理/内存上面。</p>
<h3 id="bitmap填充率">Bitmap填充率</h3>
<p>我们采用一张大的Bitmap绘制弹幕，那么这张Bitmap的利用率是非常重要的，他不仅影响在native的大小，更重要的是影响显存，毕竟显存占用是我们需要突破的一个点。我们需要每一批弹幕近可能的占用更小的Bitmap(Bitmap的利用率提升)，考虑到Bitmap的复用问题，我们不可能每次都创建一个恰好合适的Bitmap，我们对选取的Bitmap的尺寸进行理合到多个尺寸上。</p>
<h3 id="纹理上传时机选择">纹理上传时机选择</h3>
<p>因为弹幕预排版的缘故，一批弹幕添加到系统可能被排在离屏M的位置，在这个时候我们依旧把它绘制到Bitmap上面并进行了纹理的上传，但是这个时候其实没有这个必要，因为这批弹幕这个时候并没有需要上屏渲染，还需要（M/V)的时间才会出现在屏幕之上，这时绘制和上传之后，这个纹理的存活周期被拉长了，导致一定时间内存在的纹理的数量增加。  有了这个想法之后，我们可以修改Bitmap绘制和纹理上传的时机，把这个过程移到该批弹幕快要上屏的时刻在执行，这个具体的阈值距离可以在运行中统计Bitmap绘制+纹理上传的时间来进行动态调整，只要在保证到达屏幕边缘的时候可以有纹理可用就行。</p>
<h3 id="重复弹幕复用">重复弹幕复用</h3>
<p>在直播场景中经常会出现同一时刻出现很多相同弹幕的场景(游戏胜利/抽奖)，弹幕量大并且弹幕的内容相同，这是如果依然把每条弹幕绘制到Bitmap上再进行上传展示将浪费CPU内存显存资源。为了应对这种情况，我们复用相同弹幕，对于相同的弹幕我们只在Bitmap上面绘制一次，其他相同的弹幕都引用这同一块区域，然后在OpenGL绘制的时候，在根据纹理坐标绘制复原出多条弹幕。当然，在此基础之后，还可以做“子序列”类型的弹幕复用，不过实现相对麻烦，没有实现。</p>
<h3 id="bitmap通道复用">Bitmap通道复用</h3>
<p>在采用 了以上方案之后，可以缓解部分问题，是否还存在更大的优化空间呢？这是我们想到是否可以采用只在Bitmap上面绘制透明度，将具体的着色的效果交由Shader完成，这样我们在Bitmap的创建以及纹理的上传只需要只有透明通道的Bitmap，这样理论上内存/显存大小可以降低到原来的4倍(采用ARGB_4444的也会被强制转为ARGB_8888)，但是采用单个透明通道绘制出来的多颜色弹幕(如弹幕中含有表情😊)的彩色信息会被丢弃掉。为此我们还是选择ARGB4通道的Bitmap来进行绘制，对于多颜色弹幕还是按照普通的绘制方案，对于单一颜色的弹幕我们将他的透明度透射到ARGB中的一个通道。经过对我们外网弹幕的分析，大约</p>
<pre><code>70%
</code></pre>
<p>的弹幕都属于单一颜色弹幕，为此理想情况下会有减少</p>
<p><strong>3倍</strong></p>
<p>以上的内存显存占用(0.3 * 1 + 0.7 * 4)。 如何才能实现不同弹幕在同一像素上的不同通道呢，其实Android已经已经有相关的方案，在绘制Bitmap的时候通过给paint设置</p>
<pre><code>Xfermode
</code></pre>
<p>可以实现不同的叠加效果，寻找一圈就会发现</p>
<p><a href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html#ADD">PorterDuff.Mode.ADD</a></p>
<p>基本满足我们的需求。</p>
<p>!https://www.kutear.com/post-images/1584674381264.png</p>
<p>对于两次叠加他的Alpha通道和Color通道都取值大的，但在实际操作中发现对于全透明的情况是会被忽略掉，比如(FF000000和00FF0000叠加还是FF000000，不是我们所期望的FFFF0000)，所以Alpha通道的复用行不通，都得填充FF。基于这个样的操作，我们将弹幕原本的Alpha通道绘制到Bitmap的RGB通道之一中去，就可以得到如下的Bitmap。</p>
<p>!https://www.kutear.com/post-images/1584670990231.png</p>
<p>使用工具分离出ARGB各自的信息，可以得到各个通道的图像信息。</p>
<p>!https://www.kutear.com/post-images/1584704657139.png</p>
<p>有了这些信息，我们在Shader中就可以利用弹幕的真正颜色(RGB)和纹理中的某个通道(A)合并成像素点的真实颜色信息。 注：该实现因为Bitmap的Alpha通道无法使用，不能给弹幕添加阴影效果，如果有阴影会退化成多颜色弹幕处理。</p>
<h1 id="后记">后记</h1>
<p>做了这些内存/显存上的优化，在弹幕量大的情况下，显存的占用已经低于B站弹幕，但在少数弹幕的场景依然有改进空间，在弹幕量少的情况下，弹幕本身就不可能铺满全屏，可以采用可以通过减少Surface的默认高度来进行调整，这个方案初步验证是可以降低<code>EGL mtrack</code>的大小，后面会继续探索。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://github.com/bilibili/DanmakuFlameMaster">bilibili/DanmakuFlameMaster</a></li>
<li><a href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode.html">PorterDuff.Mode</a></li>
</ul>
<h1 id="附录">附录</h1>
<ul>
<li>imagemagick分离ARGB为独立图片 <code>shell convert input.png -channel RGBA -separate channels_%d.png</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android ADB 安装过程]]></title>
        <id>https://www.kutear.com/post/android-adb-an-zhuang-guo-cheng/</id>
        <link href="https://www.kutear.com/post/android-adb-an-zhuang-guo-cheng/">
        </link>
        <updated>2017-03-12T12:48:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="表皮">表皮</h1>
<p>系统默认的安装器<a href="https://android.googlesource.com/platform/packages/apps/PackageInstaller/+/marshmallow-release/src/com/android/packageinstaller/PackageInstallerActivity.java">com/android/packageinstaller/PackageInstallerActivity.java</a>。</p>
<p>点击安装会执行</p>
<pre><code class="language-java">    private void startInstall() {        // Start subactivity to actually install the application        Intent newIntent = new Intent();        newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,                mPkgInfo.applicationInfo);        newIntent.setData(mPackageURI);        newIntent.setClass(this, InstallAppProgress.class);        newIntent.putExtra(InstallAppProgress.EXTRA_MANIFEST_DIGEST, mPkgDigest);        newIntent.putExtra(                InstallAppProgress.EXTRA_INSTALL_FLOW_ANALYTICS, mInstallFlowAnalytics);        String installerPackageName = getIntent().getStringExtra(                Intent.EXTRA_INSTALLER_PACKAGE_NAME);        if (mOriginatingURI != null) {            newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI);        }        if (mReferrerURI != null) {            newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI);        }        if (mOriginatingUid != VerificationParams.NO_UID) {            newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid);        }        if (installerPackageName != null) {            newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME,                    installerPackageName);        }        if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) {            newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true);            newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);        }        if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI);        startActivity(newIntent);        finish();    }
</code></pre>
<p>启动<code>InstallAppProgress.java</code>会执行</p>
<pre><code class="language-java">PackageManager pm = getPackageManager();//originatingUid为发起安装的app的uid//originatingURI,referrer也都是标识安装的发起者VerificationParams verificationParams = new VerificationParams(null, originatingURI,                referrer, originatingUid, manifestDigest);pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,                    installerPackageName, verificationParams, null);
</code></pre>
<p>上面代码我们大概过一下知道<code>mPackageURI</code>是APK的路径，<code>observer</code>是观察APK安装的一个观察者，<code>installFlag</code>设置安装标记，比如replace已有的APK,<code>installerPackageName</code>大概是发起安装的APK的的app的包名(待确认)。</p>
<h1 id="核心">核心</h1>
<p>下文基于android-sdk-23。</p>
<p>到此我们进入Android核心之一的<code>PackageManager</code>。介于之前对Android系统级<code>Manager</code>的了解， <code>PackageManager</code>的子类<code>ApplicationPackageManager</code>其实引用的是一个<code>IPackageManager</code>,而<code>IPackageManager</code>的实现就是<code>PackageManagerService</code>(以下简称<code>PMS</code>)，在函数<code>installPackageWithVerificationAndEncryption()</code>中实际上调用了<code>PMS</code>的<code>installPackage(...)</code>函数。</p>
<pre><code class="language-java">installPackage(String originPath, IPackageInstallObserver2 observer,int installFlags, String installerPackageName,VerificationParams verificationParams,String packageAbiOverride)
</code></pre>
<p>这个函数的逻辑包括以下几部分逻辑</p>
<ol>
<li>检查当前使设备的人是否拥有安装apk的权限，检查调用安装apk的程序是否含有安装apk的权限。</li>
<li>使用<code>UserHandle</code>指示安装的apk归属于哪一个用户。</li>
<li>使用<code>Handler</code>发送一个<code>INIT_COPY</code>的消息。</li>
</ol>
<p><code>INIT_COPY</code>中把<code>InstallParams</code>(持有待安装app的信息)存入一个列表,然后在发送另外一个消息<code>MCS_BOUND</code>。在<code>MCS_BOUND</code>中会从上文中存放<code>InstallParams</code>的列表中依次取出待安装apk的部分信息。对于依次取出的<code>InstallParams</code>在执行函数<code>InstallParams#startCopy()</code>,在这个函数中会进行<code>media container service</code>绑定，如果多次(4次)尝试绑定都失败的话，就表示安装失败，退出，否则执行函数<code>InstallParams#handleStartCopy()</code>,<code>handleStartCopy()</code>方法很长,它的逻辑包含以下几点</p>
<ol>
<li>判断安装位置，根据<code>DefaultContainerServie#getMinimalPackageInfo()</code>获取推荐位置</li>
<li>判断/data/app空间是否足够，否则释放cache在尝试</li>
<li>如果启动了包验证的话，就会进入验证阶段</li>
<li>没有启动验证或验证通过进入<code>InstallArgs#copyApk(...)</code></li>
</ol>
<p>这里<code>copyApk(...)</code>的作用大致是</p>
<ol>
<li>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间（data/app/vmdl
<ul>
<li>**.tmp目录）</li>
</ul>
</li>
<li>得到申请的那部分空间的文件描述符，并且修改权限</li>
<li>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中</li>
<li>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</li>
</ol>
<p>!http://kutear.qiniudn.com/2017/02/21/fc925c470b4d9785e69c8aebf1c387d9.png</p>
<p>到此app的所有文件拷贝到了<code>data/app/vmdl***.tmp</code>目录下。此时的目录结构大致如下</p>
<pre><code>data/app/vmdl***.tmp/
                    /base.apk
                    /split_***.apk  ???
                    /lib
                       /lib***.so
</code></pre>
<p>在函数<code>InstallParams#handleStartCopy()</code>之后，是执行函数<code>InstallParams#handleReturnCode()</code> ，这个函数的逻辑主要包括一下几个要点：</p>
<ol>
<li>安装App之前的操作（<code>InstallArgs#doPreInstall(...)</code>）</li>
<li>安装App(<code>installPackageLI(...)</code>)</li>
<li>安装App之后的操作(<code>InstallArgs#doPostInstall(res.returnCode, res.uid);</code>)</li>
<li>备份操作</li>
</ol>
<p>安装之前主要是处理清理工作，删除一些文件目录。</p>
<p>// TODO</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/19578947">Android内核解读-应用的安装过程</a></li>
<li><a href="https://guolei1130.github.io/2017/01/04/Android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E7%9A%84/">Android应用程序是如何安装的</a></li>
<li><a href="http://www.ieveryday.pub/index.php/Andriod_Framework_Work_Note_Url_6">使用PackageInstaller安装app流程学习小结</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android View 事件处理]]></title>
        <id>https://www.kutear.com/post/android-view-shi-jian-chu-li/</id>
        <link href="https://www.kutear.com/post/android-view-shi-jian-chu-li/">
        </link>
        <updated>2016-03-12T12:49:51.000Z</updated>
        <content type="html"><![CDATA[<p>@Override    public boolean dispatchTouchEvent(MotionEvent ev) {        if (mInputEventConsistencyVerifier != null) {            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);        }        // If the event targets the accessibility focused view and this is it, start        // normal event dispatch. Maybe a descendant is what will handle the click.        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) {            ev.setTargetAccessibilityFocus(false);        }        boolean handled = false;        //当View被遮挡时是否继续事件分发        if (onFilterTouchEventForSecurity(ev)) {            final int action = ev.getAction();            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;//ACTION_MASK = 0xff            // Handle an initial down.            //一个事件时有DOWN开始,经过无数的MOVE,最后以UP结束            //所以如果为DOWN,就做一些初始化的工作            if (actionMasked == MotionEvent.ACTION_DOWN) {                // Throw away all previous state when starting a new touch gesture.                // The framework may have dropped the up or cancel event for the previous gesture                // due to an app switch, ANR, or some other state change.                //把上一个事件取消,即发送Action为ACTION_CANCEL的事件给mFirstTouchTarget这个链表上的View                //并且清空mFirstTouchTarget上的View,因为新的事件来了,要重置接受的View                cancelAndClearTouchTargets(ev);                resetTouchState();            }            // Check for interception.            //判断是否要拦截事件,即是否分发给Child View            final boolean intercepted;            if (actionMasked == MotionEvent.ACTION_DOWN                    || mFirstTouchTarget != null) {                      //requestDisallowInterceptTouchEvent(true)时 ---&gt; disallowIntercept = true                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;                if (!disallowIntercept) {                    intercepted = onInterceptTouchEvent(ev);                    ev.setAction(action); // restore action in case it was changed                } else {                    intercepted = false;                }            } else {                // There are no touch targets and this action is not an initial down                // so this view group continues to intercept touches.                intercepted = true;            }            //如果intercepted = true,意味着ViewGroup拦截了该事件,那么Child View将不会收到该事件            //反之Child View可以收到事件            // If intercepted, start normal event dispatch. Also if there is already            // a view that is handling the gesture, do normal event dispatch.            if (intercepted || mFirstTouchTarget != null) {                ev.setTargetAccessibilityFocus(false);            }            // Check for cancelation.            //检查是否这个事件已经被取消            final boolean canceled = resetCancelNextUpFlag(this)                    || actionMasked == MotionEvent.ACTION_CANCEL;            // Update list of touch targets for pointer down, if needed.            // 默认为<code>true</code>，分发给多个<code>View</code>（比如几个子<code>View</code>位置重叠）            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;            TouchTarget newTouchTarget = null;            boolean alreadyDispatchedToNewTouchTarget = false;            //事件没有被取消,并且当前ViewGroup没有拦截该事件,            //那么执行下面的分发过程            if (!canceled &amp;&amp; !intercepted) {                // If the event is targeting accessiiblity focus we give it to the                // view that has accessibility focus and if it does not handle it                // we clear the flag and dispatch the event to all children as usual.                // We are looking up the accessibility focused host to avoid keeping                // state since these events are very rare.                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()                        ? findChildWithAccessibilityFocus() : null;                //这里特别注意,只有在DOWN的时候会执行,也就是平时我们知道的                //之后在对DOWN事件做了处理(拦截),在以后的事件序列我们才可以收的到,                //因为后续的事件不会再判断哪些child会处理该事件,而仅仅是通过DOWN是                //保存在mFirstTouchTarget中的数据来分发,不再mFirstTouchTarget当然也就                //不能接收到事件了                //也就是说，如果ViewGroup的某个孩子没有接受ACTION_DOWN事件；那么，                //ACTION_MOVE和ACTION_UP等事件也一定不会分发给这个孩子！                if (actionMasked == MotionEvent.ACTION_DOWN                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {                    //获取touch 事件的index                    final int actionIndex = ev.getActionIndex(); // always 0 for down                    //ev.getPointerId() ==&gt;                    //* Return the pointer identifier associated with a particular pointer                    //* data index is this event.  The identifier tells you the actual pointer                    //* number associated with the data, accounting for individual pointers                    //* going up and down since the start of the current gesture.                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)                            : TouchTarget.ALL_POINTER_IDS;                    // Clean up earlier touch targets for this pointer id in case they                    // have become out of sync.                    removePointersFromTouchTargets(idBitsToAssign);                    final int childrenCount = mChildrenCount;                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) {                        final float x = ev.getX(actionIndex); //返回X方向坐标                        final float y = ev.getY(actionIndex);                        // Find a child that can receive the event.                        // Scan children from front to back.                        final ArrayList<View> preorderedList = buildOrderedChildList();                        final boolean customOrder = preorderedList == null                                &amp;&amp; isChildrenDrawingOrderEnabled();                        final View[] children = mChildren;                        for (int i = childrenCount - 1; i &gt;= 0; i--) {                            final int childIndex = customOrder                                    ? getChildDrawingOrder(childrenCount, i) : i;                            final View child = (preorderedList == null)                                    ? children[childIndex] : preorderedList.get(childIndex);                            // If there is a view that has accessibility focus we want it                            // to get the event first and if not handled we will perform a                            // normal dispatch. We may do a double iteration but this is                            // safer given the timeframe.                            if (childWithAccessibilityFocus != null) {                                if (childWithAccessibilityFocus != child) {                                    continue;                                }                                childWithAccessibilityFocus = null;                                i = childrenCount - 1;                            }                            //该View不能接收事件,可能该View当前不可见                            if (!canViewReceivePointerEvents(child)                                    || !isTransformedTouchPointInView(x, y, child, null)) {                                ev.setTargetAccessibilityFocus(false);                                continue;                            }                            //在此说明该child可以接受事件                            newTouchTarget = getTouchTarget(child);  //返回该View对应的TouchTarget                            if (newTouchTarget != null) {                                // Child is already receiving touch within its bounds.                                // Give it the new pointer in addition to the ones it is handling.                                newTouchTarget.pointerIdBits |= idBitsToAssign;                                break;                            }                            resetCancelNextUpFlag(child);                            //事件分发给child                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {                                // Child wants to receive touch within its bounds.                                mLastTouchDownTime = ev.getDownTime();                                if (preorderedList != null) {                                    // childIndex points into presorted list, find original index                                    for (int j = 0; j &lt; childrenCount; j++) {                                        if (children[childIndex] == mChildren[j]) {                                            mLastTouchDownIndex = j;                                            break;                                        }                                    }                                } else {                                    mLastTouchDownIndex = childIndex;                                }                                mLastTouchDownX = ev.getX();                                mLastTouchDownY = ev.getY();                                //把可以接受事件的View加到mFirstTouchTarget的表头                                newTouchTarget = addTouchTarget(child, idBitsToAssign);                                alreadyDispatchedToNewTouchTarget = true;                                break;                            }                            // The accessibility focus didn't handle the event, so clear                            // the flag and do a normal dispatch to all children.                            ev.setTargetAccessibilityFocus(false);                        }                        if (preorderedList != null) preorderedList.clear();                    }                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {                        // Did not find a child to receive the event.                        // Assign the pointer to the least recently added target.                        newTouchTarget = mFirstTouchTarget;                        while (newTouchTarget.next != null) {                            newTouchTarget = newTouchTarget.next;                        }                        newTouchTarget.pointerIdBits |= idBitsToAssign;                    }                }            }            // Dispatch to touch targets.            // 说明没有child来处理该事件,则有该ViewGroup自己处理            if (mFirstTouchTarget == null) {                // No touch targets so treat this as an ordinary view.                // 内部调用 --&gt; super.dispatchTouchEvent(transformedEvent);                // 由于这里super为View,view.dispatchTouchEvent(transformedEvent)会把事件                // 拿给自己的onTouchEvent/onTouch处理                handled = dispatchTransformedTouchEvent(ev, canceled, null,                        TouchTarget.ALL_POINTER_IDS);            } else {              //否则分发给child处理                // Dispatch to touch targets, excluding the new touch target if we already                // dispatched to it.  Cancel touch targets if necessary.                TouchTarget predecessor = null;                TouchTarget target = mFirstTouchTarget;                while (target != null) {                    final TouchTarget next = target.next;                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {                        handled = true;                    } else {                        final boolean cancelChild = resetCancelNextUpFlag(target.child)                                || intercepted;                        if (dispatchTransformedTouchEvent(ev, cancelChild,                                target.child, target.pointerIdBits)) {                            handled = true;                        }                        if (cancelChild) {                            if (predecessor == null) {                                mFirstTouchTarget = next;                            } else {                                predecessor.next = next;                            }                            target.recycle();                            target = next;                            continue;                        }                    }                    predecessor = target;                    target = next;                }            }            // Update list of touch targets for pointer up or cancel, if needed.            if (canceled                    || actionMasked == MotionEvent.ACTION_UP                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {                resetTouchState();            } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {                final int actionIndex = ev.getActionIndex();                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);                removePointersFromTouchTargets(idBitsToRemove);            }        }        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);        }        return handled;    }</p>
]]></content>
    </entry>
</feed>