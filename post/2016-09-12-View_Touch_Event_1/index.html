<!DOCTYPE html>
<html>
  <head lang="zh">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<meta content="telephone=no" name="format-detection"/>
<meta name="renderer" content="webkit">
<meta name="description" content="æ¸©æ•…è€ŒçŸ¥æ–°">
<meta http-equiv="Access-Control-Allow-Origin" content="*">

<title>ViewGroupäº‹ä»¶åˆ†å‘1 | KuTeat</title>
<link href="https://kutear.github.io/styles/main.css" type="text/css" rel="stylesheet"/>
<link rel="stylesheet" href="//cdn.bootcss.com/KaTeX/0.10.2/katex.min.css"/>
<script src="//cdn.bootcss.com/KaTeX/0.10.2/katex.min.js"></script>
<script src="//cdn.bootcss.com/KaTeX/0.10.2/contrib/auto-render.min.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/jquery.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/jquery.pjax.min.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/basic.js"></script>
<script type="text/javascript" src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script async type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async type="text/javascript" src="https://kutear.github.io/media/scripts/search.js"></script>
<script type="text/javascript">
$(document).pjax('a[target!=_blank]', '#pjax-container', {
	fragment: '#pjax-container',
	timeout: 5000,
	cache: false
});
$(document).on('pjax:complete', function(){  	
	pjax();
});

$(window).on('popstate.pjax', function () {
	pjax();
})

function pjax() {
	$.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");

	if (("#gitalk-container").length > 0 ) {
	$('#mememe').attr('src','//source.unsplash.com/800x400/?arts,weather?'+Math.random());
	$.getScript("//cdn.bootcss.com/KaTeX/0.10.2/katex.min.js");
	$.getScript("//cdn.bootcss.com/KaTeX/0.10.2/contrib/auto-render.min.js");
	$('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
    	});
	}
}
</script>

  </head>

  <body>
     <div class="header">
      <div class="logo_title">
		  
        <div class="title animated fadeInDown"><img id="img1" style="display:inline-block;" src="https://kutear.github.io/images/avatar.png"/>
<script>
var r = 0;
    window.onload = function(){
        var current = 0;
        document.getElementById('img1').onclick = function(){
            current = (current+90)%360;
            this.style.transform = 'rotate('+current+'deg)';
        }
    };
</script>
          <h1 title="KuTeat" class="weaklink"><a  href="/">KuTeat</a>

          </h1>

          <div class="navbar weaklink">
            <div class="normal_nav">

<div class="bitcron_nav_container">


  <div class="bitcron_nav">
    <div class="mixed_site_nav_wrap site_nav_wrap">
		
      <ul class="mixed_site_nav site_nav sm sm-base">
	  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >é¦–é¡µ</a>
  </li>
  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >å½’æ¡£</a>
  </li>
  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >æ ‡ç­¾</a>
  </li>
  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >å…³äº</a>
  </li>
  
 
 <li>

      </ul>
	  

      <div class="clear clear_nav_inline_end"></div>
<div class="search">
    <i class="search-icon fa fa-search search-start"></i>
    <input type="text" class="search-input" placeholder="Searching..." />
    <i class="search-icon fa fa-refresh search-clear"></i>
	<div class="search-results"></div>
</div>
    </div>

  </div>



  <div class="clear clear_nav_end"></div>

</div>

            </div>
			
			<div class="hamberger"><i class="fa fa-bars"></i>
<i class="fa fa-times"></i>

			</div>

          </div>

        </div>

      </div>

      <div class="hidden_nav animated fadeInDown">

<div class="bitcron_nav_container">


  <div class="bitcron_nav">
    <div class="mixed_site_nav_wrap site_nav_wrap">
      <ul class="mixed_site_nav site_nav sm sm-base">
	
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >é¦–é¡µ</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >å½’æ¡£</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >æ ‡ç­¾</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >å…³äº</a>

  </li>




      </ul>

      <div class="clear clear_nav_inline_end"></div>
    </div>

  </div>



  <div class="clear clear_nav_end"></div>

</div>

      </div>

    </div>

<style type="text/css">
.search {
    position: relative;
    height: 30px;
    text-align: right;
    line-height: 30px;
    padding-right: 10px;
}

.search .search-icon {
    float: right;
    height: 100%;
    margin: 0 10px;
    line-height: 30px;
    cursor: pointer;
    user-select: none;
}

.search .search-input {
    float: right;
    width: 30%;
    height: 30px;
    line-height: 30px;
    margin: 0;
    border: 2px solid #ddd;
    border-radius: 10px;
    box-sizing: border-box;
}

.search .search-clear {
    display: none;
}

.search .search-results {
    display: block;
    z-index: 1000;
    position: absolute;
    top: 30px;
    right: 50px;
    width: 50%;
    max-height: 400px;
    overflow: auto;
    text-align: left;
    border-radius: 5px;
    box-shadow: 0 .3rem .5rem #333;
}

.search .search-results .result-item {
    color: #000;
    margin: 5px;
    padding: 3px;
    border-radius: 3px;
    cursor: pointer;
}

</style>

    <div class="main" id="pjax-container">
      <div class="main-inner">


<div class="content">






  <div class="post_page" >

<div class="post">
  <div class="post_title sm_margin">
    <h2><a>ViewGroupäº‹ä»¶åˆ†å‘1</a>



    </h2>
  </div>
  
<script>
function lan(){
	if (document.getElementById("lan").innerText == "ç¹"){
		var s=document.getElementById("tongwenlet_cn");
		if(s != null){
		document.body.removeChild(s);
		}
		var s = document.createElement("script");
		s.language = "javascript";
		s.type = "text/javascript";
		s.src = "https://git.oschina.net/runningcheese/JiathisQR.js/raw/master/bookmarklet_tw.js";
		s.id = "tongwenlet_cn";
		document.body.appendChild(s);
		document.getElementById("lan").innerHTML = "ç®€"
	}
	else if(document.getElementById("lan").innerText == "ç°¡"){
		var s=document.getElementById("tongwenlet_cn");
		if(s != null){
		document.body.removeChild(s);
		}
		var s = document.createElement("script");
		s.language = "javascript";
		s.type = "text/javascript";
		s.src = "https://git.oschina.net/runningcheese/JiathisQR.js/raw/master/bookmarklet_cn.js";
		s.id = "tongwenlet_cn";
		document.body.appendChild(s);
		document.getElementById("lan").innerHTML = "ç¹"
		}
}

function change(){	
    var rand = Math.random()*1+1;
    var num = window.getComputedStyle(document.getElementsByName("show")[0],undefined).fontSize;
	num = num.slice(0,-2); 
    document.getElementById("show").style.fontSize = num - rand +'px';
}
</script>

  <div class="post_details">
    <div class="info"><i class="fa fa-clock-o"></i>
<span class="date_info">2016-09-12</span>
<i class="fa fa-eye"></i>

<span class="date_info"><span id="busuanzi_value_page_pv"></span> Views</span>

<i class="fa fa-bookmark-o"></i>
<span class="tags_info weaklink">
	
	<a href="https://kutear.github.io/tag/23BKTXLtA" class="tag">View</a>

	<a href="https://kutear.github.io/tag/w-_t1J-CXe" class="tag">Touch</a>


</span>
<span>10 min read</span>
&nbsp
&nbsp
<i class="fa fa-share"></i>
<a title="QR code" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kutear.github.io/post/2016-09-12-View_Touch_Event_1"><i class="fa fa-qrcode"></i></a>
<a title="qq share" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://kutear.github.io/post/2016-09-12-View_Touch_Event_1&sharesource=qzone&title=ViewGroupäº‹ä»¶åˆ†å‘1&pics=https://blog.blinkstar.cn/images/avatar.png&summary="><i class="fa fa-qq"></i></a>
<a title="weibo share" target="_blank" href="https://service.weibo.com/share/share.php?url=https://kutear.github.io/post/2016-09-12-View_Touch_Event_1&sharesource=weibo&title=ViewGroupäº‹ä»¶åˆ†å‘1 + " - " + &pic="https://blog.blinkstar.cn/images/avatar.png"><i class="fa fa-weibo"></i></a>
&nbsp
&nbsp
<a id="daxiao" href="javascript:void(0);" onclick="change();" title="è°ƒæ•´å­—ä½“å¤§å°"><i class="fa fa-font"></i></a>
&nbsp
&nbsp
<a id="lan" href="javascript:void(0);" onclick="lan();" title="è°ƒæ•´ç®€ç¹ä½“">ç¹</a>
</div>
  </div>

  <div class="post_content markdown">
  &nbsp
  <img id="mememe" src="//source.unsplash.com/800x400/?arts,weather">
    <div name="show" id="show">
	<p class="md_block"><span class="md_line md_line_start md_line_end"><p>å…³é”®å­—æ®µè¯´æ˜</p>
<pre><code class="language-java">// First touch target in the linked list of touch targets.
//ä¸€ä¸ªè§¦æ‘¸äº‹ä»¶å¯èƒ½æœ‰å¤šä¸ªViewå¯ä»¥æ¥æ”¶åˆ°,è¯¥å‚æ•°æŠŠä»–ä»¬è¿æ¥æˆé“¾çŠ¶
private TouchTarget mFirstTouchTarget;
</code></pre>
<p>å‡½æ•°è¯´æ˜</p>
<pre><code class="language-java">@Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        }

        // If the event targets the accessibility focused view and this is it, start
        // normal event dispatch. Maybe a descendant is what will handle the click.
        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) {
            ev.setTargetAccessibilityFocus(false);
        }

        boolean handled = false;
        //å½“Viewè¢«é®æŒ¡æ—¶æ˜¯å¦ç»§ç»­äº‹ä»¶åˆ†å‘
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;//ACTION_MASK = 0xff

            // Handle an initial down.
            //ä¸€ä¸ªäº‹ä»¶æ—¶æœ‰DOWNå¼€å§‹,ç»è¿‡æ— æ•°çš„MOVE,æœ€åä»¥UPç»“æŸ
            //æ‰€ä»¥å¦‚æœä¸ºDOWN,å°±åšä¸€äº›åˆå§‹åŒ–çš„å·¥ä½œ
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                //æŠŠä¸Šä¸€ä¸ªäº‹ä»¶å–æ¶ˆ,å³å‘é€Actionä¸ºACTION_CANCELçš„äº‹ä»¶ç»™mFirstTouchTargetè¿™ä¸ªé“¾è¡¨ä¸Šçš„View
                //å¹¶ä¸”æ¸…ç©ºmFirstTouchTargetä¸Šçš„View,å› ä¸ºæ–°çš„äº‹ä»¶æ¥äº†,è¦é‡ç½®æ¥å—çš„View
                cancelAndClearTouchTargets(ev);   

                resetTouchState();
            }

            // Check for interception.
            //åˆ¤æ–­æ˜¯å¦è¦æ‹¦æˆªäº‹ä»¶,å³æ˜¯å¦åˆ†å‘ç»™Child View
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                      //requestDisallowInterceptTouchEvent(true)æ—¶ ---&gt; disallowIntercept = true
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            //å¦‚æœintercepted = true,æ„å‘³ç€ViewGroupæ‹¦æˆªäº†è¯¥äº‹ä»¶,é‚£ä¹ˆChild Viewå°†ä¸ä¼šæ”¶åˆ°è¯¥äº‹ä»¶
            //åä¹‹Child Viewå¯ä»¥æ”¶åˆ°äº‹ä»¶

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            if (intercepted || mFirstTouchTarget != null) {
                ev.setTargetAccessibilityFocus(false);
            }

            // Check for cancelation.
            //æ£€æŸ¥æ˜¯å¦è¿™ä¸ªäº‹ä»¶å·²ç»è¢«å–æ¶ˆ
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            // é»˜è®¤ä¸º`true`ï¼Œåˆ†å‘ç»™å¤šä¸ª`View`ï¼ˆæ¯”å¦‚å‡ ä¸ªå­`View`ä½ç½®é‡å ï¼‰
            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            //äº‹ä»¶æ²¡æœ‰è¢«å–æ¶ˆ,å¹¶ä¸”å½“å‰ViewGroupæ²¡æœ‰æ‹¦æˆªè¯¥äº‹ä»¶,
            //é‚£ä¹ˆæ‰§è¡Œä¸‹é¢çš„åˆ†å‘è¿‡ç¨‹
            if (!canceled &amp;&amp; !intercepted) {

                // If the event is targeting accessiiblity focus we give it to the
                // view that has accessibility focus and if it does not handle it
                // we clear the flag and dispatch the event to all children as usual.
                // We are looking up the accessibility focused host to avoid keeping
                // state since these events are very rare.
                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;


                //è¿™é‡Œç‰¹åˆ«æ³¨æ„,åªæœ‰åœ¨DOWNçš„æ—¶å€™ä¼šæ‰§è¡Œ,ä¹Ÿå°±æ˜¯å¹³æ—¶æˆ‘ä»¬çŸ¥é“çš„
                //ä¹‹ååœ¨å¯¹DOWNäº‹ä»¶åšäº†å¤„ç†(æ‹¦æˆª),åœ¨ä»¥åçš„äº‹ä»¶åºåˆ—æˆ‘ä»¬æ‰å¯ä»¥æ”¶çš„åˆ°,
                //å› ä¸ºåç»­çš„äº‹ä»¶ä¸ä¼šå†åˆ¤æ–­å“ªäº›childä¼šå¤„ç†è¯¥äº‹ä»¶,è€Œä»…ä»…æ˜¯é€šè¿‡DOWNæ˜¯
                //ä¿å­˜åœ¨mFirstTouchTargetä¸­çš„æ•°æ®æ¥åˆ†å‘,ä¸å†mFirstTouchTargetå½“ç„¶ä¹Ÿå°±
                //ä¸èƒ½æ¥æ”¶åˆ°äº‹ä»¶äº†
                //ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœViewGroupçš„æŸä¸ªå­©å­æ²¡æœ‰æ¥å—ACTION_DOWNäº‹ä»¶ï¼›é‚£ä¹ˆï¼Œ
                //ACTION_MOVEå’ŒACTION_UPç­‰äº‹ä»¶ä¹Ÿä¸€å®šä¸ä¼šåˆ†å‘ç»™è¿™ä¸ªå­©å­ï¼
                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    //è·å–touch äº‹ä»¶çš„index
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    //ev.getPointerId() ==&gt;
                    //* Return the pointer identifier associated with a particular pointer
                    //* data index is this event.  The identifier tells you the actual pointer
                    //* number associated with the data, accounting for individual pointers
                    //* going up and down since the start of the current gesture.
                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                        final float x = ev.getX(actionIndex); //è¿”å›Xæ–¹å‘åæ ‡
                        final float y = ev.getY(actionIndex);
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();
                        final boolean customOrder = preorderedList == null
                                &amp;&amp; isChildrenDrawingOrderEnabled();
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) {
                            final int childIndex = customOrder
                                    ? getChildDrawingOrder(childrenCount, i) : i;
                            final View child = (preorderedList == null)
                                    ? children[childIndex] : preorderedList.get(childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }

                            //è¯¥Viewä¸èƒ½æ¥æ”¶äº‹ä»¶,å¯èƒ½è¯¥Viewå½“å‰ä¸å¯è§
                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }

                            //åœ¨æ­¤è¯´æ˜è¯¥childå¯ä»¥æ¥å—äº‹ä»¶
                            newTouchTarget = getTouchTarget(child);  //è¿”å›è¯¥Viewå¯¹åº”çš„TouchTarget
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            //äº‹ä»¶åˆ†å‘ç»™child
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                //æŠŠå¯ä»¥æ¥å—äº‹ä»¶çš„ViewåŠ åˆ°mFirstTouchTargetçš„è¡¨å¤´
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }

                            // The accessibility focus didn't handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        }
                        if (preorderedList != null) preorderedList.clear();
                    }

                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }
            }

            // Dispatch to touch targets.
            // è¯´æ˜æ²¡æœ‰childæ¥å¤„ç†è¯¥äº‹ä»¶,åˆ™æœ‰è¯¥ViewGroupè‡ªå·±å¤„ç†
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                // å†…éƒ¨è°ƒç”¨ --&gt; super.dispatchTouchEvent(transformedEvent);
                // ç”±äºè¿™é‡Œsuperä¸ºView,view.dispatchTouchEvent(transformedEvent)ä¼šæŠŠäº‹ä»¶
                // æ‹¿ç»™è‡ªå·±çš„onTouchEvent/onTouchå¤„ç†
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
              //å¦åˆ™åˆ†å‘ç»™childå¤„ç†
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                resetTouchState();
            } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }
</code></pre>
<pre><code class="language-java">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled;

    // Canceling motions is a special case.  We don't need to perform any transformations
    // or filtering.  The important part is the action, not the contents.
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            handled = super.dispatchTouchEvent(event);
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }

    // Calculate the number of pointers to deliver.
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;

    // If for some reason we ended up in an inconsistent state where it looks like we
    // might produce a motion event with no pointers in it, then drop the event.
    if (newPointerIdBits == 0) {
        return false;
    }

    // If the number of pointers is the same and we don't need to perform any fancy
    // irreversible transformations, then we can reuse the motion event for this
    // dispatch as long as we are careful to revert any changes we make.
    // Otherwise we need to make a copy.
    final MotionEvent transformedEvent;
    if (newPointerIdBits == oldPointerIdBits) {
        if (child == null || child.hasIdentityMatrix()) {
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);

                handled = child.dispatchTouchEvent(event);

                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        transformedEvent = MotionEvent.obtain(event);
    } else {
        transformedEvent = event.split(newPointerIdBits);
    }

    // Perform any necessary transformations and dispatch.
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }

        handled = child.dispatchTouchEvent(transformedEvent);
    }

    // Done.
    transformedEvent.recycle();
    return handled;
}
</code></pre>
</span></p></div>
	<br>
	<hr>
<div style="color: #ccc;font-size:14px;"><i class="fa fa-user"></i>æœ¬æ–‡ç”±<a rel="license" href="/">KuTeat</a>åˆ›ä½œ</div>	
<div style="color: #ccc;font-size:14px;"><i class="fa fa-cc"></i>è¯¥æ–‡ç« é‡‡ç”¨<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">çŸ¥è¯†å…±äº«ç½²å-éå•†ä¸šæ€§ä½¿ç”¨ 4.0 å›½é™…è®¸å¯åè®®</a>è¿›è¡Œè®¸å¯ã€‚è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼</div>
<div style="color: #ccc;font-size:14px;"><i class="fa fa-clock-o"></i>å‘å¸ƒæ—¶é—´ä¸ºï¼š2016-09-12</div>    
	 <p class="md_block">
    <div class="reward"><div class="reward-button">èµ <span class="reward-code"> <span class="alipay-code"> <img class="alipay-img" src="https://kutear.github.io/media/images/alipay.png"><b>æ”¯ä»˜å®æ‰«ç æ‰“èµ</b> </span> <span class="wechat-code"> <img class="wechat-img" src="https://kutear.github.io/media/images/wechat.png"><b>å¾®ä¿¡æ‰“èµ</b> </span> </span></div></div>
<div style="text-align:center;color: #ccc;font-size:14px;">å¦‚æœè§‰å¾—è¿™ç¯‡æ–‡ç« å¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œå¯ä»¥è¯·ä½œè€…å–ä¸€æ¯é¥®æ–™å“¦ğŸ¥¤</div>    
</p> 
</div>
</div>

<style type="text/css">
#mememe {
	border:3px;
	border-radius:5px;
    background-repeat: no-repeat;
    height: 100%;
	width: 100%;
	display: inline-block;
	border-radius:5px; 
}
</style>

<script>
var link = "" ;
$("img").each( (i,o) => {
	var o = $(o);
	if( o.attr("src").indexOf("sinaimg") > 0 || o.attr("src").indexOf("qpic") > 0 || o.attr("src").indexOf("baidu") > 0 || o.attr("src").indexOf("sinaimg") > 0){
		o.attr("referrerpolicy","no-referrer");
		link = o.attr("src");
		o.attr("src",link);
	}
});
</script>

<div style="width:100%;overflow:hidden">

          <div style="float:right;text-align:right;color:#ccc;font-size:18px;width:50%;">
            ä¸‹ä¸€ç¯‡
            <a href="https://kutear.github.io/post/2016-08-30-SparseArray">
              <h3 class="post-title">
                SparseArray åŸç†åˆ†æ
              </h3>
            </a>
          </div>



          <div style="float:left;text-align:left;color:#ccc;font-size:18px;width:50%;">
            ä¸Šä¸€ç¯‡
            <a href="https://kutear.github.io/post/2016-09-20-Android-Windows">
              <h3 class="post-title">
                å¯¹Window/WindowManagerå’ŒWindowManagerSystemçš„ç†è§£
              </h3>
            </a>
          </div>

</div>

<div class="doc_comments">

</div>

  </div>
</div>


      </div>
<div class="toc-container">

</div>
    </div>
	
   <div class="footer">
<div class="site_footer_wrap"><div class="site_footer">

      <div class="mysocials"><div class="my_socials">
		   
			   
    
			   
    
			   
    
			   
    
			   
    
			   
    
</div>
      </div>

      <div class="copyright" id="copyright">
	  <script>
		var date=new Date;
		var year=date.getFullYear(); 
		document.write("Copyright Â© "+year+" " + "KuTeat. ");
		</script>
		Powered by Gridea.
		<br>
		æœ¬ç«™å·²ç¨³å®šè¿è¡Œäº†
		<strong><script type="text/javascript">
		var urodz= new Date("10/28/2018");
		var now = new Date();
		var ile = now.getTime() - urodz.getTime();
		var dni = Math.floor(ile / (1000 * 60 * 60 * 24));
		document.write(+dni)
		</script>
		</strong>å¤©
		<br>
		æœ¬ç«™æ€»è®¿é—®é‡ä¸º <strong><span id="busuanzi_value_site_uv"></span></strong> æ¬¡
	  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
      </div>
	  <img src="https://kutear.github.io/media/images/font.svg">

    </div>

<script type="text/javascript" src="https://kutear.github.io/media/scripts/love.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/darkmode.js"></script>
<script>
var options = {
  bottom: '64px', // default: '32px'
  right: '32px', // default: '32px'
  left: 'unset', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: false, // default: true,
  label: 'ğŸŒ“', // default: ''
  autoMatchOsTheme: true // default: true
}

const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script>
hljs.initHighlightingOnLoad();
</script>

</body>

</html>
