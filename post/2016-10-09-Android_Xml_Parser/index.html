<!DOCTYPE html>
<html>
  <head lang="zh">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<meta content="telephone=no" name="format-detection"/>
<meta name="renderer" content="webkit">
<meta name="description" content="温故而知新">
<meta http-equiv="Access-Control-Allow-Origin" content="*">

<title>Android中View,Drawable,Animation从XML中解析生成的过程 | KuTeat</title>
<link href="https://kutear.github.io/styles/main.css" type="text/css" rel="stylesheet"/>
<link rel="stylesheet" href="//cdn.bootcss.com/KaTeX/0.10.2/katex.min.css"/>
<script src="//cdn.bootcss.com/KaTeX/0.10.2/katex.min.js"></script>
<script src="//cdn.bootcss.com/KaTeX/0.10.2/contrib/auto-render.min.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/jquery.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/jquery.pjax.min.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/basic.js"></script>
<script type="text/javascript" src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script async type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async type="text/javascript" src="https://kutear.github.io/media/scripts/search.js"></script>
<script type="text/javascript">
$(document).pjax('a[target!=_blank]', '#pjax-container', {
	fragment: '#pjax-container',
	timeout: 5000,
	cache: false
});
$(document).on('pjax:complete', function(){  	
	pjax();
});

$(window).on('popstate.pjax', function () {
	pjax();
})

function pjax() {
	$.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");

	if (("#gitalk-container").length > 0 ) {
	$('#mememe').attr('src','//source.unsplash.com/800x400/?arts,weather?'+Math.random());
	$.getScript("//cdn.bootcss.com/KaTeX/0.10.2/katex.min.js");
	$.getScript("//cdn.bootcss.com/KaTeX/0.10.2/contrib/auto-render.min.js");
	$('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
    	});
	}
}
</script>

  </head>

  <body>
     <div class="header">
      <div class="logo_title">
		  
        <div class="title animated fadeInDown"><img id="img1" style="display:inline-block;" src="https://kutear.github.io/images/avatar.png"/>
<script>
var r = 0;
    window.onload = function(){
        var current = 0;
        document.getElementById('img1').onclick = function(){
            current = (current+90)%360;
            this.style.transform = 'rotate('+current+'deg)';
        }
    };
</script>
          <h1 title="KuTeat" class="weaklink"><a  href="/">KuTeat</a>

          </h1>

          <div class="navbar weaklink">
            <div class="normal_nav">

<div class="bitcron_nav_container">


  <div class="bitcron_nav">
    <div class="mixed_site_nav_wrap site_nav_wrap">
		
      <ul class="mixed_site_nav site_nav sm sm-base">
	  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a>
  </li>
  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a>
  </li>
  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a>
  </li>
  
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a>
  </li>
  
 
 <li>

      </ul>
	  

      <div class="clear clear_nav_inline_end"></div>
<div class="search">
    <i class="search-icon fa fa-search search-start"></i>
    <input type="text" class="search-input" placeholder="Searching..." />
    <i class="search-icon fa fa-refresh search-clear"></i>
	<div class="search-results"></div>
</div>
    </div>

  </div>



  <div class="clear clear_nav_end"></div>

</div>

            </div>
			
			<div class="hamberger"><i class="fa fa-bars"></i>
<i class="fa fa-times"></i>

			</div>

          </div>

        </div>

      </div>

      <div class="hidden_nav animated fadeInDown">

<div class="bitcron_nav_container">


  <div class="bitcron_nav">
    <div class="mixed_site_nav_wrap site_nav_wrap">
      <ul class="mixed_site_nav site_nav sm sm-base">
	
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a>

  </li>




      </ul>

      <div class="clear clear_nav_inline_end"></div>
    </div>

  </div>



  <div class="clear clear_nav_end"></div>

</div>

      </div>

    </div>

<style type="text/css">
.search {
    position: relative;
    height: 30px;
    text-align: right;
    line-height: 30px;
    padding-right: 10px;
}

.search .search-icon {
    float: right;
    height: 100%;
    margin: 0 10px;
    line-height: 30px;
    cursor: pointer;
    user-select: none;
}

.search .search-input {
    float: right;
    width: 30%;
    height: 30px;
    line-height: 30px;
    margin: 0;
    border: 2px solid #ddd;
    border-radius: 10px;
    box-sizing: border-box;
}

.search .search-clear {
    display: none;
}

.search .search-results {
    display: block;
    z-index: 1000;
    position: absolute;
    top: 30px;
    right: 50px;
    width: 50%;
    max-height: 400px;
    overflow: auto;
    text-align: left;
    border-radius: 5px;
    box-shadow: 0 .3rem .5rem #333;
}

.search .search-results .result-item {
    color: #000;
    margin: 5px;
    padding: 3px;
    border-radius: 3px;
    cursor: pointer;
}

</style>

    <div class="main" id="pjax-container">
      <div class="main-inner">


<div class="content">






  <div class="post_page" >

<div class="post">
  <div class="post_title sm_margin">
    <h2><a>Android中View,Drawable,Animation从XML中解析生成的过程</a>



    </h2>
  </div>
  
<script>
function lan(){
	if (document.getElementById("lan").innerText == "繁"){
		var s=document.getElementById("tongwenlet_cn");
		if(s != null){
		document.body.removeChild(s);
		}
		var s = document.createElement("script");
		s.language = "javascript";
		s.type = "text/javascript";
		s.src = "https://git.oschina.net/runningcheese/JiathisQR.js/raw/master/bookmarklet_tw.js";
		s.id = "tongwenlet_cn";
		document.body.appendChild(s);
		document.getElementById("lan").innerHTML = "简"
	}
	else if(document.getElementById("lan").innerText == "簡"){
		var s=document.getElementById("tongwenlet_cn");
		if(s != null){
		document.body.removeChild(s);
		}
		var s = document.createElement("script");
		s.language = "javascript";
		s.type = "text/javascript";
		s.src = "https://git.oschina.net/runningcheese/JiathisQR.js/raw/master/bookmarklet_cn.js";
		s.id = "tongwenlet_cn";
		document.body.appendChild(s);
		document.getElementById("lan").innerHTML = "繁"
		}
}

function change(){	
    var rand = Math.random()*1+1;
    var num = window.getComputedStyle(document.getElementsByName("show")[0],undefined).fontSize;
	num = num.slice(0,-2); 
    document.getElementById("show").style.fontSize = num - rand +'px';
}
</script>

  <div class="post_details">
    <div class="info"><i class="fa fa-clock-o"></i>
<span class="date_info">2016-10-10</span>
<i class="fa fa-eye"></i>

<span class="date_info"><span id="busuanzi_value_page_pv"></span> Views</span>

<i class="fa fa-bookmark-o"></i>
<span class="tags_info weaklink">
	

</span>
<span>18 min read</span>
&nbsp
&nbsp
<i class="fa fa-share"></i>
<a title="QR code" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://kutear.github.io/post/2016-10-09-Android_Xml_Parser"><i class="fa fa-qrcode"></i></a>
<a title="qq share" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://kutear.github.io/post/2016-10-09-Android_Xml_Parser&sharesource=qzone&title=Android中View,Drawable,Animation从XML中解析生成的过程&pics=https://blog.blinkstar.cn/images/avatar.png&summary="><i class="fa fa-qq"></i></a>
<a title="weibo share" target="_blank" href="https://service.weibo.com/share/share.php?url=https://kutear.github.io/post/2016-10-09-Android_Xml_Parser&sharesource=weibo&title=Android中View,Drawable,Animation从XML中解析生成的过程 + " - " + &pic="https://blog.blinkstar.cn/images/avatar.png"><i class="fa fa-weibo"></i></a>
&nbsp
&nbsp
<a id="daxiao" href="javascript:void(0);" onclick="change();" title="调整字体大小"><i class="fa fa-font"></i></a>
&nbsp
&nbsp
<a id="lan" href="javascript:void(0);" onclick="lan();" title="调整简繁体">繁</a>
</div>
  </div>

  <div class="post_content markdown">
  &nbsp
  <img id="mememe" src="//source.unsplash.com/800x400/?arts,weather">
    <div name="show" id="show">
	<p class="md_block"><span class="md_line md_line_start md_line_end"><h1 id="view">View</h1>
<p>对于<code>View</code>我们常见的使用就是两种，一种是<code>setContent(int)</code>，另一种为<code>LayoutInflater.inflate()</code>,其本质都是一样的。皆为<code>LayoutInflater.inflate()</code>,我们分析一下这里的具体实现。</p>
<pre><code class="language-java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    final XmlResourceParser parser = res.getLayout(resource); //根据xml返回一个解析器
    try {
        return inflate(parser, root, attachToRoot);

    } finally {
        parser.close();
    }
}
</code></pre>
<p>接着就是函数<code>inflate()</code>.</p>
<pre><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
      final String name = parser.getName();
      if (TAG_MERGE.equals(name)) { //如果是&lt;merge /&gt;标签
          if (root == null || !attachToRoot) {
              throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;
                      + &quot;ViewGroup root and attachToRoot=true&quot;);
          }
          //内部也是通过函数createViewFromTag()生成View,并调用rInflateChildren()递归解析
         rInflate(parser, root, inflaterContext, attrs, false);
    } else {
        // Temp is the root view that was found in the xml
        //根据当前标签tag创建View
        final View temp = createViewFromTag(root, name, inflaterContext, attrs);
        ViewGroup.LayoutParams params = null;
        if (root != null) {
          //获取xml中的属性，如宽高，待为view设置layoutparams
            params = root.generateLayoutParams(attrs);  
            if (!attachToRoot) {
                // Set the layout params for temp if we are not
                // attaching. (If we are, we use addView, below)
                temp.setLayoutParams(params);
            }
        }

        // Inflate all children under temp against its context.
        //把当前解析的view作为parent,继续递归解析她的child View         
        rInflateChildren(parser, temp, attrs, true);
        // We are supposed to attach all the views we found (int temp)
        // to root. Do that now.
        if (root != null &amp;&amp; attachToRoot) {
          //最后把当前解析的view添加到他的parent中
            root.addView(temp, params);      
        }

        // Decide whether to return the root that was passed in or the
        // top view found in xml.
        if (root == null || !attachToRoot) {
            result = temp;
        }
      }
      return result;
    }
}
</code></pre>
<p>上面的函数非常容易理解，我们现在要看的函数就是<code>createViewFromTag()</code></p>
<pre><code class="language-java">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,
        boolean ignoreThemeAttr) {
    if (name.equals(&quot;view&quot;)) {
        name = attrs.getAttributeValue(null, &quot;class&quot;);
    }
    //原来xml还可以写成
    //&lt;view class=&quot;TextView&quot; ...&gt;的形式
    //&lt;blink&gt;标签  实现闪烁的如&lt;blink&gt;&lt;TextView text=&quot;AA&quot; ...&gt;&lt;/blink&gt; 那么AA会闪烁
    if (name.equals(TAG_1995)) {
        // Let's party like it's 1995!
        return new BlinkLayout(context, attrs);
    }

    try {
        View view;
        ...
        //这里有一些Factory创建方式，但是他的逻辑和下面一样，不多说
        ...
        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(parent, name, attrs); //不含. 一定是系统的View,如TextView
                } else {
                    view = createView(name, null, attrs);  //非系统VIew 如支持库的View,自定义的View
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }

        return view;
    } catch (InflateException e) {
      ...
    }
}
</code></pre>
<p>通过源码，我们发现<code>onCreateView(..)</code>其实是调用<code>createView(name, &quot;android.view.&quot;, attrs)</code>,只是人为的加上View的前缀。</p>
<pre><code class="language-java">public final View createView(String name, String prefix, AttributeSet attrs)
        throws ClassNotFoundException, InflateException {
    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);  //构造函数缓存
    Class&lt;? extends View&gt; clazz = null;

    try {

        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(
                    prefix != null ? (prefix + name) : name).asSubclass(View.class);
            ...
            //    static final Class&lt;?&gt;[] mConstructorSignature = new Class[] {
            //                                Context.class, AttributeSet.class};
            constructor = clazz.getConstructor(mConstructorSignature);//这里我们就可以看到为什么View在xml实例时调用两个参数的构造函数
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(
                            prefix != null ? (prefix + name) : name).asSubclass(View.class);

                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }

        Object[] args = mConstructorArgs;
        args[1] = attrs;

        final View view = constructor.newInstance(args); //实例化View对象
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            //对于ViewStub,现在还没解析其内部结构，待调用函数inflate()时才解析替换为内部的View。
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;

    } catch (NoSuchMethodException e) {
      ...
    }
}
</code></pre>
<p>到此View的解析就算完了。</p>
<h1 id="drawable">Drawable</h1>
<p>这里以Background为例说明，在View的构造哈数中存在这样一段代码</p>
<pre><code class="language-java">//View.java
final TypedArray a = context.obtainStyledAttributes(
                attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);
int attr = a.getIndex(i);
switch (attr) {
    case com.android.internal.R.styleable.View_background:
        background = a.getDrawable(attr);
        break;
    case ..
}        
</code></pre>
<pre><code class="language-java">//TypedArray.java
@Nullable
public Drawable getDrawable(int index) {
  ...
  return mResources.loadDrawable(value, value.resourceId, mTheme);
}
</code></pre>
<p>在<code>loadDrawable()</code>当中，做了一些判断，比如当前要的<code>Drawable</code>是否已经加载过了，即判断是否已经在缓存中，如果在就不需要从xml中加载，反之就需要加载，并保存在缓存中。而加载就是调用函数<code>loadDrawableForCookie()</code>,下面看看具体的实现。</p>
<pre><code class="language-java">private Drawable loadDrawableForCookie(TypedValue value, int id, Theme theme) {
    if (value.string == null) {
        throw new NotFoundException(&quot;Resource \&quot;&quot; + getResourceName(id) + &quot;\&quot; (&quot;
                + Integer.toHexString(id) + &quot;) is not a Drawable (color or path): &quot; + value);
    }

    final String file = value.string.toString(); //这里是文件的路径 如res/drawable/xxx.png
    final Drawable dr;
    try {
        if (file.endsWith(&quot;.xml&quot;)) {
            final XmlResourceParser rp = loadXmlResourceParser(
                    file, id, value.assetCookie, &quot;drawable&quot;);
            dr = Drawable.createFromXml(this, rp, theme);
            rp.close();
        } else {
            final InputStream is = mAssets.openNonAsset(
                    value.assetCookie, file, AssetManager.ACCESS_STREAMING);
            dr = Drawable.createFromResourceStream(this, value, is, file, null);
            is.close();
        }
    } catch (Exception e) {

    }
    return dr;
}
</code></pre>
<p>很容易看到，这里以xml结尾的文件和其他如png结尾的文件做了分别处理，先看看简单的普通的图片格式，也就是<code>else</code>中的代码。可以看见是很简单的实现，就是把图片转换为数据流，在通过数据流构建Drawable对象。重点看看xml类型Drawable的生成吧。跟入进去，我们发现有个特别的函数<code>createFromXmlInner()</code>，为什么说特别？因为它就是创建具体<code>Drawable</code>的函数。</p>
<pre><code class="language-java">public static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs,
        Theme theme) throws XmlPullParserException, IOException {
    final Drawable drawable;

    final String name = parser.getName();
    switch (name) {
        case &quot;selector&quot;:
            drawable = new StateListDrawable();
            break;
        case &quot;animated-selector&quot;:
            drawable = new AnimatedStateListDrawable();
            break;
        case &quot;level-list&quot;:
            drawable = new LevelListDrawable();
            break;
        case &quot;layer-list&quot;:
            drawable = new LayerDrawable();
            break;
        case &quot;transition&quot;:
            drawable = new TransitionDrawable();
            break;
        case &quot;ripple&quot;:
            drawable = new RippleDrawable();
            break;
        case &quot;color&quot;:
            drawable = new ColorDrawable();
            break;
        case &quot;shape&quot;:
            drawable = new GradientDrawable();
            break;
        case &quot;vector&quot;:
            drawable = new VectorDrawable();
            break;
        case &quot;animated-vector&quot;:
            drawable = new AnimatedVectorDrawable();
            break;
        case &quot;scale&quot;:
            drawable = new ScaleDrawable();
            break;
        case &quot;clip&quot;:
            drawable = new ClipDrawable();
            break;
        case &quot;rotate&quot;:
            drawable = new RotateDrawable();
            break;
        case &quot;animated-rotate&quot;:
            drawable = new AnimatedRotateDrawable();
            break;
        case &quot;animation-list&quot;:
            drawable = new AnimationDrawable();
            break;
        case &quot;inset&quot;:
            drawable = new InsetDrawable();
            break;
        case &quot;bitmap&quot;:
            drawable = new BitmapDrawable();
            break;
        case &quot;nine-patch&quot;:
            drawable = new NinePatchDrawable();
            break;
        default:
            throw new XmlPullParserException(parser.getPositionDescription() +
                    &quot;: invalid drawable tag &quot; + name);

    }
    drawable.inflate(r, parser, attrs, theme);
    return drawable;
}
</code></pre>
<p>前面的<code>switch</code>就是简单的根据标签tag创建具体的对象，最后调用<code>drawable.inflate()</code>来配置具体的参数。这里我们一帧动画<code>AnimationDrawable</code>来说明。</p>
<pre><code class="language-java">@Override
public void inflate(Resources r, XmlPullParser parser, AttributeSet attrs, Theme theme)
        throws XmlPullParserException, IOException {
    final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.AnimationDrawable);
    super.inflateWithAttributes(r, parser, a, R.styleable.AnimationDrawable_visible);
    updateStateFromTypedArray(a);
    a.recycle();
    inflateChildElements(r, parser, attrs, theme);
}

private void inflateChildElements(Resources r, XmlPullParser parser, AttributeSet attrs,
        Theme theme) throws XmlPullParserException, IOException {
    int type;

    final int innerDepth = parser.getDepth()+1;
    int depth;
    //循环获取每一帧动画信息
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT
            &amp;&amp; ((depth = parser.getDepth()) &gt;= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }

        if (depth &gt; innerDepth || !parser.getName().equals(&quot;item&quot;)) {
            continue;
        }
        //取得每个名为item的tag结点
        final TypedArray a = obtainAttributes(r, theme, attrs,
                R.styleable.AnimationDrawableItem);

        final int duration = a.getInt(R.styleable.AnimationDrawableItem_duration, -1);
        if (duration &lt; 0) {
            throw new XmlPullParserException(parser.getPositionDescription()
                    + &quot;: &lt;item&gt; tag requires a 'duration' attribute&quot;);
        }

        Drawable dr = a.getDrawable(R.styleable.AnimationDrawableItem_drawable); //按照解析png的方式解析

        a.recycle();

        if (dr == null) {
            while ((type=parser.next()) == XmlPullParser.TEXT) {
                // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription()
                        + &quot;: &lt;item&gt; tag requires a 'drawable' attribute or child tag&quot;
                        + &quot; defining a drawable&quot;);
            }
            dr = Drawable.createFromXmlInner(r, parser, attrs, theme);  //item内部再嵌xml类型的Drawable
        }

        mAnimationState.addFrame(dr, duration); //添加到存储每一帧的容器，带播放时使用
        if (dr != null) {
            dr.setCallback(this);
        }
    }
}
</code></pre>
<p>对于<code>Drawable</code>的解析大体就这些。</p>
<h1 id="animation">Animation</h1>
<p>我们知道，Android动画大体分为三类，帧动画，View 动画，和属性动画。帧动画在上面Drawable已经说过了。而View动画和属性动画基本一样的解析。下面以属性动画为例看一下。我们选择从函数<code>loadAnimator(Context context, @AnimatorRes int id)</code>入手。</p>
<pre><code class="language-java">public static Animator loadAnimator(Resources resources, Theme theme, int id,
            float pathErrorScale) throws NotFoundException {
        final ConfigurationBoundResourceCache&lt;Animator&gt; animatorCache = resources
                .getAnimatorCache();
        Animator animator = animatorCache.getInstance(id, theme); //优先缓存读取
        if (animator != null) {
            return animator;
        } else if (DBG_ANIMATOR_INFLATER) {
            Log.d(TAG, &quot;cache miss for animator &quot; + resources.getResourceName(id));
        }
        //缓存中不存在，需要解析
        XmlResourceParser parser = null;
        try {
            parser = resources.getAnimation(id);
            animator = createAnimatorFromXml(resources, theme, parser, pathErrorScale);//动画的创建
            if (animator != null) {
                animator.appendChangingConfigurations(getChangingConfigs(resources, id));
                final ConstantState&lt;Animator&gt; constantState = animator.createConstantState();
                if (constantState != null) {
                    if (DBG_ANIMATOR_INFLATER) {
                        Log.d(TAG, &quot;caching animator for res &quot; + resources.getResourceName(id));
                    }
                    animatorCache.put(id, theme, constantState);
                    // create a new animator so that cached version is never used by the user
                    // 这里的注释说明每次从缓存中读取的cache其实也是通过这种方式创建的。
                    animator = constantState.newInstance(resources, theme);
                }
            }
            return animator;
        } catch (XmlPullParserException ex) {
            ...
        } finally {
            if (parser != null) parser.close();
        }
    }
</code></pre>
<p>毕竟这不是我们这里需要主要关注的，下面我们看看创建的函数<code>createAnimatorFromXml()</code>.</p>
<pre><code class="language-java">private static Animator createAnimatorFromXml(Resources res, Theme theme, XmlPullParser parser,
        AttributeSet attrs, AnimatorSet parent, int sequenceOrdering, float pixelSize)
        throws XmlPullParserException, IOException {
    Animator anim = null;
    ArrayList&lt;Animator&gt; childAnims = null;

    // Make sure we are on a start tag.
    int type;
    int depth = parser.getDepth();

    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth)
            &amp;&amp; type != XmlPullParser.END_DOCUMENT) {

        if (type != XmlPullParser.START_TAG) {
            continue;
        }

        String name = parser.getName();
        boolean gotValues = false;

        if (name.equals(&quot;objectAnimator&quot;)) {  //生成objectAnimator
            anim = loadObjectAnimator(res, theme, attrs, pixelSize);
        } else if (name.equals(&quot;animator&quot;)) { //ValueAnimator
            anim = loadAnimator(res, theme, attrs, null, pixelSize);  //递归过程
        } else if (name.equals(&quot;set&quot;)) {  //AnimatorSet
            //我们知道，AnimatorSet是个容器，这里的逻辑就是把它作为parent,在递归解析子元素
            anim = new AnimatorSet();
            TypedArray a;
            if (theme != null) {
                a = theme.obtainStyledAttributes(attrs, R.styleable.AnimatorSet, 0, 0);
            } else {
                a = res.obtainAttributes(attrs, R.styleable.AnimatorSet);
            }
            anim.appendChangingConfigurations(a.getChangingConfigurations());
            int ordering = a.getInt(R.styleable.AnimatorSet_ordering, TOGETHER);
            createAnimatorFromXml(res, theme, parser, attrs, (AnimatorSet) anim, ordering,
                    pixelSize); //递归调用
            a.recycle();
        } else if (name.equals(&quot;propertyValuesHolder&quot;)) {  //这里面还会解析keyframe标签
            PropertyValuesHolder[] values = loadValues(res, theme, parser,
                    Xml.asAttributeSet(parser));
            if (values != null &amp;&amp; anim != null &amp;&amp; (anim instanceof ValueAnimator)) {
                ((ValueAnimator) anim).setValues(values);
            }
            gotValues = true;
        } else {
            throw new RuntimeException(&quot;Unknown animator name: &quot; + parser.getName());
        }

        if (parent != null &amp;&amp; !gotValues) {
            if (childAnims == null) {
                childAnims = new ArrayList&lt;Animator&gt;();
            }
            childAnims.add(anim);
        }
    }
    //生成完毕，考虑添加到Parent
    if (parent != null &amp;&amp; childAnims != null) {
        Animator[] animsArray = new Animator[childAnims.size()];
        int index = 0;
        for (Animator a : childAnims) {
            animsArray[index++] = a;
        }
        if (sequenceOrdering == TOGETHER) {
            parent.playTogether(animsArray);
        } else {
            parent.playSequentially(animsArray);
        }
    }
    return anim;
}
</code></pre>
<p>有点抽象，下面我们先写一个小例子看看动画的所有结构。</p>
<pre><code class="language-xml">&lt;set android:ordering=&quot;sequentially&quot;&gt;
      &lt;animator
            android:duration=&quot;1000&quot;
            android:repeatCount=&quot;1&quot;
            android:repeatMode=&quot;reverse&quot;&gt;
      &lt;propertyValuesHolder&gt;
          &lt;keyframe android:fraction=&quot;0&quot; android:value=&quot;1&quot;/&gt;
          &lt;keyframe android:fraction=&quot;.2&quot; android:value=&quot;.4&quot;/&gt;
          &lt;keyframe android:fraction=&quot;1&quot; android:value=&quot;0&quot;/&gt;
      &lt;/propertyValuesHolder&gt;
    &lt;/animator&gt;
    &lt;objectAnimator
        android:duration=&quot;500&quot;
        android:valueTo=&quot;1f&quot;&gt;
          &lt;propertyValuesHolder android:propertyName=&quot;x&quot; &gt;
                &lt;keyframe android:fraction=&quot;0&quot; android:value=&quot;800&quot; /&gt;
                &lt;keyframe android:fraction=&quot;.2&quot;
                          android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
                          android:value=&quot;1000&quot; /&gt;
                &lt;keyframe android:fraction=&quot;1&quot;
                          android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
                          android:value=&quot;400&quot; /&gt;
          &lt;/propertyValuesHolder&gt;
          &lt;propertyValuesHolder android:propertyName=&quot;y&quot; &gt;
                &lt;keyframe/&gt;
                &lt;keyframe android:fraction=&quot;.2&quot;
                          android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
                          android:value=&quot;300&quot;/&gt;
                &lt;keyframe android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
                          android:value=&quot;1000&quot; /&gt;
          &lt;/propertyValuesHolder&gt;
      &lt;/objectAnimator&gt;
&lt;/set&gt;
</code></pre>
<p>我们接下来以<code>&lt;propertyValuesHolder/&gt;</code>的解析为例来说明。</p>
<pre><code class="language-java">private static PropertyValuesHolder[] loadValues(Resources res, Theme theme,
            XmlPullParser parser, AttributeSet attrs) throws XmlPullParserException, IOException {
        ArrayList&lt;PropertyValuesHolder&gt; values = null;

        int type;
        while ((type = parser.getEventType()) != XmlPullParser.END_TAG &amp;&amp;
                type != XmlPullParser.END_DOCUMENT) {

            if (type != XmlPullParser.START_TAG) {
                parser.next();
                continue;
            }

            String name = parser.getName();

            if (name.equals(&quot;propertyValuesHolder&quot;)) {
                TypedArray a;
                if (theme != null) {
                    a = theme.obtainStyledAttributes(attrs, R.styleable.PropertyValuesHolder, 0, 0);
                } else {
                    a = res.obtainAttributes(attrs, R.styleable.PropertyValuesHolder);
                }
                String propertyName = a.getString(R.styleable.PropertyValuesHolder_propertyName);
                int valueType = a.getInt(R.styleable.PropertyValuesHolder_valueType,
                        VALUE_TYPE_UNDEFINED);

                PropertyValuesHolder pvh = loadPvh(res, theme, parser, propertyName, valueType);
                if (pvh == null) {
                    pvh = getPVH(a, valueType,
                            R.styleable.PropertyValuesHolder_valueFrom,
                            R.styleable.PropertyValuesHolder_valueTo, propertyName);
                }
                if (pvh != null) {
                    if (values == null) {
                        values = new ArrayList&lt;PropertyValuesHolder&gt;();
                    }
                    values.add(pvh);
                }
                a.recycle();
            }

            parser.next();
        }

        PropertyValuesHolder[] valuesArray = null;
        if (values != null) {
            int count = values.size();
            valuesArray = new PropertyValuesHolder[count];
            for (int i = 0; i &lt; count; ++i) {
                valuesArray[i] = values.get(i);
            }
        }
        return valuesArray;
    }
</code></pre>
<p>上面代码没什么可说的，唯一要看的就是<code>PropertyValuesHolder</code>的创建函数<code>loadPvh()</code>。</p>
<pre><code class="language-java">private static PropertyValuesHolder loadPvh(Resources res, Theme theme, XmlPullParser parser,
        String propertyName, int valueType)
        throws XmlPullParserException, IOException {

    PropertyValuesHolder value = null;
    ArrayList&lt;Keyframe&gt; keyframes = null;

    int type;
    while ((type = parser.next()) != XmlPullParser.END_TAG &amp;&amp;
            type != XmlPullParser.END_DOCUMENT) {
        String name = parser.getName();
        if (name.equals(&quot;keyframe&quot;)) {
            if (valueType == VALUE_TYPE_UNDEFINED) {
                valueType = inferValueTypeOfKeyframe(res, theme, Xml.asAttributeSet(parser));
            }
            //解析keyframe
            Keyframe keyframe = loadKeyframe(res, theme, Xml.asAttributeSet(parser), valueType);  
            if (keyframe != null) {
                if (keyframes == null) {
                    keyframes = new ArrayList&lt;Keyframe&gt;();
                }
                keyframes.add(keyframe);
            }
            parser.next();
        }
    }

    int count;
    if (keyframes != null &amp;&amp; (count = keyframes.size()) &gt; 0) {
        ...对keyframes的调整
        value = PropertyValuesHolder.ofKeyframe(propertyName, keyframeArray); //设置keyframe
        if (valueType == VALUE_TYPE_COLOR) {
            value.setEvaluator(ArgbEvaluator.getInstance());//设置估值器
        }
    }

    return value;
}
</code></pre>
<p>卧槽，一层一层何时能到头。</p>
<pre><code class="language-java">private static Keyframe loadKeyframe(Resources res, Theme theme, AttributeSet attrs,
        int valueType)
        throws XmlPullParserException, IOException {

    TypedArray a;
    if (theme != null) {
        a = theme.obtainStyledAttributes(attrs, R.styleable.Keyframe, 0, 0);
    } else {
        a = res.obtainAttributes(attrs, R.styleable.Keyframe);
    }

    Keyframe keyframe = null;

    float fraction = a.getFloat(R.styleable.Keyframe_fraction, -1);

    TypedValue keyframeValue = a.peekValue(R.styleable.Keyframe_value);
    boolean hasValue = (keyframeValue != null);
    if (valueType == VALUE_TYPE_UNDEFINED) {
        // When no value type is provided, check whether it's a color type first.
        // If not, fall back to default value type (i.e. float type).
        if (hasValue &amp;&amp; isColorType(keyframeValue.type)) {
            valueType = VALUE_TYPE_COLOR;
        } else {
            valueType = VALUE_TYPE_FLOAT;
        }
    }

    if (hasValue) {
        switch (valueType) {
            case VALUE_TYPE_FLOAT:
                float value = a.getFloat(R.styleable.Keyframe_value, 0);
                keyframe = Keyframe.ofFloat(fraction, value);
                break;
            case VALUE_TYPE_COLOR:
            case VALUE_TYPE_INT:
                int intValue = a.getInt(R.styleable.Keyframe_value, 0);
                keyframe = Keyframe.ofInt(fraction, intValue);
                break;
        }
    } else {
        keyframe = (valueType == VALUE_TYPE_FLOAT) ? Keyframe.ofFloat(fraction) :
                Keyframe.ofInt(fraction);
    }

    final int resID = a.getResourceId(R.styleable.Keyframe_interpolator, 0);
    if (resID &gt; 0) {
        final Interpolator interpolator = AnimationUtils.loadInterpolator(res, theme, resID); //插值器，和View动画一致
        keyframe.setInterpolator(interpolator);
    }
    a.recycle();

    return keyframe;
}
</code></pre>
<p>上面函数很简单，就是根据不同的type生成不同的keyframe,而type我们从上面知道是从TypedValue.type来判断的。TypedValue中持有很多的type声明</p>
<pre><code class="language-java">...
public static final int TYPE_DIMENSION = 0x05;
/** The &lt;var&gt;data&lt;/var&gt; field holds a complex number encoding a fraction
 *  of a container. */
public static final int TYPE_FRACTION = 0x06;
...
</code></pre>
<p>好了，到这里就算分析完了,里面有很多代码现在还是不太清楚具体的逻辑。但是我们流程还是算清楚的了。</p>
</span></p></div>
	<br>
	<hr>
<div style="color: #ccc;font-size:14px;"><i class="fa fa-user"></i>本文由<a rel="license" href="/">KuTeat</a>创作</div>	
<div style="color: #ccc;font-size:14px;"><i class="fa fa-cc"></i>该文章采用<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。转载请注明出处！</div>
<div style="color: #ccc;font-size:14px;"><i class="fa fa-clock-o"></i>发布时间为：2016-10-10</div>    
	 <p class="md_block">
    <div class="reward"><div class="reward-button">赏 <span class="reward-code"> <span class="alipay-code"> <img class="alipay-img" src="https://kutear.github.io/media/images/alipay.png"><b>支付宝扫码打赏</b> </span> <span class="wechat-code"> <img class="wechat-img" src="https://kutear.github.io/media/images/wechat.png"><b>微信打赏</b> </span> </span></div></div>
<div style="text-align:center;color: #ccc;font-size:14px;">如果觉得这篇文章对您有帮助，可以请作者喝一杯饮料哦🥤</div>    
</p> 
</div>
</div>

<style type="text/css">
#mememe {
	border:3px;
	border-radius:5px;
    background-repeat: no-repeat;
    height: 100%;
	width: 100%;
	display: inline-block;
	border-radius:5px; 
}
</style>

<script>
var link = "" ;
$("img").each( (i,o) => {
	var o = $(o);
	if( o.attr("src").indexOf("sinaimg") > 0 || o.attr("src").indexOf("qpic") > 0 || o.attr("src").indexOf("baidu") > 0 || o.attr("src").indexOf("sinaimg") > 0){
		o.attr("referrerpolicy","no-referrer");
		link = o.attr("src");
		o.attr("src",link);
	}
});
</script>

<div style="width:100%;overflow:hidden">

          <div style="float:right;text-align:right;color:#ccc;font-size:18px;width:50%;">
            下一篇
            <a href="https://kutear.github.io/post/2016-10-08-Android_Property_Animator">
              <h3 class="post-title">
                Android属性动画原理
              </h3>
            </a>
          </div>



          <div style="float:left;text-align:left;color:#ccc;font-size:18px;width:50%;">
            上一篇
            <a href="https://kutear.github.io/post/2016-10-27-PMS-1">
              <h3 class="post-title">
                PackageManagerService学习--上
              </h3>
            </a>
          </div>

</div>

<div class="doc_comments">

</div>

  </div>
</div>


      </div>
<div class="toc-container">
<ul class="markdownIt-TOC">
<li><a href="#view">View</a></li>
<li><a href="#drawable">Drawable</a></li>
<li><a href="#animation">Animation</a></li>
</ul>

</div>
    </div>
	
   <div class="footer">
<div class="site_footer_wrap"><div class="site_footer">

      <div class="mysocials"><div class="my_socials">
		   
			   
    
			   
    
			   
    
			   
    
			   
    
			   
    
</div>
      </div>

      <div class="copyright" id="copyright">
	  <script>
		var date=new Date;
		var year=date.getFullYear(); 
		document.write("Copyright © "+year+" " + "KuTeat. ");
		</script>
		Powered by Gridea.
		<br>
		本站已稳定运行了
		<strong><script type="text/javascript">
		var urodz= new Date("10/28/2018");
		var now = new Date();
		var ile = now.getTime() - urodz.getTime();
		var dni = Math.floor(ile / (1000 * 60 * 60 * 24));
		document.write(+dni)
		</script>
		</strong>天
		<br>
		本站总访问量为 <strong><span id="busuanzi_value_site_uv"></span></strong> 次
	  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
      </div>
	  <img src="https://kutear.github.io/media/images/font.svg">

    </div>

<script type="text/javascript" src="https://kutear.github.io/media/scripts/love.js"></script>
<script type="text/javascript" src="https://kutear.github.io/media/scripts/darkmode.js"></script>
<script>
var options = {
  bottom: '64px', // default: '32px'
  right: '32px', // default: '32px'
  left: 'unset', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: false, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}

const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script>
hljs.initHighlightingOnLoad();
</script>

</body>

</html>
