<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kutear.github.io</id>
    <title>KuTeat</title>
    <updated>2019-11-24T07:26:11.401Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kutear.github.io"/>
    <link rel="self" href="https://kutear.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://kutear.github.io/images/avatar.png</logo>
    <icon>https://kutear.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, KuTeat</rights>
    <entry>
        <title type="html"><![CDATA[Instance Run 原理分析]]></title>
        <id>https://kutear.github.io/post/2018-01-19-Android-Build-Instant_Run</id>
        <link href="https://kutear.github.io/post/2018-01-19-Android-Build-Instant_Run">
        </link>
        <updated>2018-01-19T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="instant-run-原理">Instant run 原理</h1>
<p>编译期对所有方法进行插桩</p>
<p>例如原始代码</p>
<pre><code class="language-java">class Main{
    public void func(Context ctx){
         Toast.makeText(ctx,&quot;Hello&quot;,Toast.LENGTH_LONG).show();
    }
}
</code></pre>
<p>编译之后再<code>/build/intermediates/transforms/instantRun/Debug/{Num}/</code>下面存在插桩后的class文件[第一次生成的代码],{Num}似乎在不同环境下数值不一样</p>
<pre><code class="language-java">class Main{  
    public void func(Context ctx) {
        IncrementalChange var2 = $change;
        if(var2 != null) {
          var2.access$dispatch(&quot;func.(Landroid/content/Context;)V&quot;, new Object[]{this, ctx});
        } else {
          Toast.makeText(ctx, &quot;Hello&quot;, 1).show();
        }
      }
}
</code></pre>
<p>所以当某个类有了新的变化，只需要给<code>$change</code>字段赋值,就可以达到方法替换的目的(类似与代理)，或许你发现生成的class文件中没有<code>$change</code>的相关定义说明，我们可以通过反编译<code>/build/intermediates/transforms/dex/</code>下面的<code>dex</code>文件发现其中<code>$change</code>的定义为</p>
<pre><code class="language-java">public static volatile transient /* synthetic */ IncrementalChange $change = null;
</code></pre>
<p>使用<code>Instant Run</code>运行之后会在<code>/build/intermediates/transforms/instantRun/Debug/{Num2}/</code> 下生成出变化的class,{Num2}不同与上文的{Num}</p>
<pre><code class="language-java">public class Main$override implements IncrementalChange {
  public static void func(Main $this, Context ctx) {
    Toast.makeText(ctx, &quot;Hello&quot;, 1).show();
  }
  ...
}
</code></pre>
<p>同时还会生成一个类<code>com.android.tools.ir.runtime.AppPatchesLoaderImpl(extends AbstractPatchesLoaderImpl)</code>,在他的<code>getPatchedClasses()</code>函数中会返回所有改变了的类的全名,用于后续替换的需要。</p>
<p>然后将这些变化了的class打包成为(命令dx)dex通过<code>socket</code>发送给Client,Client拿到这个dex之后找到拿到变化了的class,并通过反射对<code>$change</code>字段进行修改，从而完成方法体的提换。</p>
<h2 id="差分dex生成">差分dex生成</h2>
<h2 id="如何实现插桩">如何实现插桩</h2>
<p>在Android Gradle1.5插件中，Google加入了一个Transform api,这个api的作用是可以操作编译之后的class文件,目前修改class文件的方式有javaasist等等第三方库,我没有看Android Gradle插件的具体的插桩的过程,这里我们可以看看javaasist的插桩的一种实现。</p>
<p>首先注册一个自己的Transform到Android Gradle中<code>project.android.registerTransform(new MyTranform(...))</code>,<code>MyTranform</code>继承自<code>Transform</code>,核心实现<code>void tranform(TransformInvocation invocation)</code>方法，我们可以冲参数中获取到传入的class dir以及 jar包。在结合javaasist对class字节码进行修改输出，就可以实现插桩。基于同样的原理，我们可以实现一个插桩(方法的开头和结尾处)来对每个方法进行耗时统计(注意递归调用的情况)，也可以通过注入一个字段来进行对类实例的个数进行统计(注意子类对父类的影响)。</p>
<h2 id="双端socket通信">双端Socket通信</h2>
<p>两端通信就是以手机端为Server,Gradle插件作为Client,Gradle插件向手机发送本次变更的类的列表,以及变更之后的一个差分patch,服务端收到patch之后保存在本地的目录,然后反射注入一些对象都待修改的类中去。</p>
<h2 id="client-端动态加载dex实现hot-swap">Client 端动态加载Dex实现Hot Swap</h2>
<p>注:这里的手机端其实是服务端</p>
<p>我们知道这个编译之后的增量包是Android Studio通过Socket穿给手机的,具体的位置在<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/Server.java#318">MESSAGE_PATCHES</a></p>
<pre><code class="language-java">case MESSAGE_PATCHES: {
    if (!authenticate(input)) {
        return;
    }
	//通过数据流读取字节码存在byte[]中
    List&lt;ApplicationPatch&gt; changes = ApplicationPatch.read(input);
    boolean hasResources = hasResources(changes);
    int updateMode = input.readInt();
    updateMode = handlePatches(changes, hasResources, updateMode);
    restart(updateMode, hasResources, showToast);
    continue;
}
</code></pre>
<p>在函数<code>handlePatches(...)</code>会对修改的文件进行处理,分为资源文件和dex文件</p>
<pre><code class="language-java">for(ApplicationPatch change : changes) {
   String path = change.getPath();
   if (path.equals(RELOAD_DEX_FILE_NAME)) {
         updateMode = handleHotSwapPatch(updateMode, change);
   } else if (isResourcePath(path)) {
         updateMode = handleResourcePatch(updateMode, change, path);
   }
}
</code></pre>
<h3 id="dex-swap">Dex Swap</h3>
<p>这里我们先看对于dex的处理,首先将byte[]的dex写到本地,然后新建一个<code>ClassLoader</code>来加载这个类,通过实例化一个类然后调用其<code>load()</code>函数。</p>
<pre><code class="language-java">try {
    String dexFile = FileManager.writeTempDexFile(patch.getBytes());
  	...
    String nativeLibraryPath = FileManager.getNativeLibraryFolder().getPath();
    DexClassLoader dexClassLoader = new DexClassLoader(dexFile,
               context.getCacheDir().getPath(), nativeLibraryPath,
               getClass().getClassLoader());
            // we should transform this process with an interface/impl
    Class&lt;?&gt; aClass = Class.forName(
                    &quot;com.android.tools.fd.runtime.AppPatchesLoaderImpl&quot;, true, dexClassLoader);
    try {
	     ...
         PatchesLoader loader = (PatchesLoader) aClass.newInstance();
         ...
         if (!loader.load()) { //核心逻辑
            updateMode = UPDATE_MODE_COLD_SWAP;
         }
     } catch (Exception e) {
         e.printStackTrace();
         updateMode = UPDATE_MODE_COLD_SWAP;
     }
} catch (Throwable e) {
    updateMode = UPDATE_MODE_COLD_SWAP;
}
</code></pre>
<p><code>load()</code>函数的具体实现在<a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/instant-run-runtime/src/main/java/com/android/tools/fd/runtime/AbstractPatchesLoaderImpl.java#30">AbstractPatchesLoaderImpl#load</a>,根据前文的介绍,我们知道这里的最终目的一定是将更改之后的类的一个代理对象赋值给<code>$change</code>字段,下面看看具体的做法。</p>
<pre><code class="language-java">for (String className : getPatchedClasses()) { //获取修改类的全名
     ClassLoader cl = getClass().getClassLoader();
     Class&lt;?&gt; aClass = cl.loadClass(className + &quot;$override&quot;);
     Object o = aClass.newInstance();
     Class&lt;?&gt; originalClass = cl.loadClass(className);
     Field changeField = originalClass.getDeclaredField(&quot;$change&quot;);
     // force the field accessibility as the class might not be &quot;visible&quot;
     // from this package.
     changeField.setAccessible(true);
	 // If there was a previous change set, mark it as obsolete:
     Object previous = changeField.get(null);
     if (previous != null) {
          Field isObsolete = previous.getClass().getDeclaredField(&quot;$obsolete&quot;);
          if (isObsolete != null) {
               isObsolete.set(null, true);
          }
      }
      changeField.set(null, o);
}
</code></pre>
<p>实现非常的简单就是通过反射修改静态字段<code>$change</code>的值。这样以后在调用的时候就能使用新的方法实现。</p>
<h3 id="res-swap">Res Swap</h3>
<p>资源替换的一个前提就是id固定,我们都知道资源id是每次编译时生成的,每次编译必然会导致id变化，如何任由它变化就是造成ResourceNotFound,如何实现资源固定网上有很多的说明，我不再重复。</p>
<blockquote>
<p>简要说来，Instant Run中的资源热修复分为两步，</p>
<p>1、构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完整的新资源包加入到AssetManager中。这样就得到了一个含有所有新资源的AssetManager。</p>
<p>2、找到所有之前引用到原有AssetManager的地方，通过反射，把引用处替换为AssetManager。</p>
</blockquote>
<p>具体的代码实现在这里可以查看<a href="https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/MonkeyPatcher.java#90">instant-run</a></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/instant-run/">Instant Run Source Code</a></li>
<li><a href="http://jiajixin.cn/2015/11/25/instant-run/">Instant Run 浅析</a></li>
<li><a href="https://halfstackdeveloper.github.io/2016/09/23/%E5%9F%BA%E4%BA%8EInstant-Run%E6%80%9D%E6%83%B3%E7%9A%84HotFix%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0/">基于Instant-Run思想的HotFix方案实现</a></li>
<li><a href="http://www.jianshu.com/p/417589a561da">通过自定义Gradle插件修改编译后的class文件</a></li>
<li><a href="http://www.jianshu.com/p/e6125ddfaea7">Android资源动态加载思路</a></li>
<li><a href="https://yq.aliyun.com/articles/96378">Android热修复升级探索——资源更新之新思路</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Retrofit 原理分析]]></title>
        <id>https://kutear.github.io/post/2017-07-01-Android_Retrofit</id>
        <link href="https://kutear.github.io/post/2017-07-01-Android_Retrofit">
        </link>
        <updated>2017-07-01T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<p>注:本文不会涉及<code>retrofit</code>的使用</p>
<h1 id="前言">前言</h1>
<p>目前Android开发主流的网络请求框架要数<code>OKHTTP</code>了,<code>retrofit</code>就是在<code>OKHTTP</code>的基础之上进行了一层封装,使得开发者使用更加的方便.如果你要问具体方便在哪里?其实就是对于请求参数的构建这一块更加的方便.使用<code>OKHTTP</code>的时候需要我们自己去构建一个<code>Request</code>对象,而<code>Retrofit</code>直接使用注解声明的方式自动帮助我们创建<code>Request</code>对象.还有一方面就是对于请求的返回值,<code>Retrofit</code>可以使用<code>Converter</code>去把返回值直接返回为具体的实例.如果结合<code>RxJava</code>使用效果更加的好.</p>
<p>说明:以下分析基于retrofit版本2.1.0</p>
<h1 id="分析">分析</h1>
<h2 id="retrofit实例构建部分">Retrofit实例构建部分</h2>
<p><code>Retrofit</code>的构建使用常用的Builder模式,其中构建的参数包括<code>OkHttpClient</code>,<code>Converter.Factory</code>,以及<code>CallAdapter.Factory</code>,他们的作用分别是<code>OkHttp</code>请求的Client,转换请求得到的数据为具体的类型,以及根据接口申明调用的不用的构建<code>Request</code>的工厂.其中<code>Converter.Factory</code>和<code>CallAdapter.Factory</code>的数量可以是多个.</p>
<p>构建好<code>Retrofit</code>的实例之后我们就可以使用它来创建网络接口.</p>
<p>在<code>Retrofit#create(...)</code>中,会使用java动态代理实现对网络接口类的访问.下面部分将会分析如何根据注解生成一个<code>Request</code>对象提供给<code>OKHTTP</code>模块使用,如何处理返回的数据转换为我们期望的类型.</p>
<h2 id="接口创建过程">接口创建过程</h2>
<p>动态代理相关的知识这里就不多说,我们把焦点集中在<code>Retrifit#create(...)</code>上,在第一行对接口类进行验证,要求必须是接口,并且没有继承至别的接口.紧接着是<code>validateEagerly</code>条件判断,这个字段是构建<code>Retrofit</code>的过程中外部赋值,如果为<code>true</code>表示在构建API接口的时候就行预先加载,可以看成是单例模式中的饿汉实现,然后就是一个动态代理,在对方法的代理时,会过滤掉默认方法,比如<code>Object</code>的相关方法,以及Java8所支持的默认接口实现方法,也就是说这些方法不是一个真正的接口的实现.代理内部最后三行代码才是我们分析的核心.</p>
<pre><code class="language-java">ServiceMethod serviceMethod = loadServiceMethod(method);
OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre>
<p>先概括的描述其各自的作用,第一行根据<code>method</code>解析他的注解得到一个<code>ServiceMethod</code>,<code>ServiceMethod</code>包含了请求所需要的字段,链接,类型等信息,第二行根据调用时的具体参数赋予上文构建出来的<code>ServiceMethod</code>,从而得到一个<code>Call</code>对象.该对象和<code>okhttpclient.newCall(...)</code>得到的效果一致(不是同一个接口,只是名字都是<code>Call</code>罢了),而最后行就是处理这个<code>Call</code>,<code>Retrofit</code>默认是没有做任何的处理</p>
<h2 id="servicemethod的构建">ServiceMethod的构建</h2>
<p><code>serviceMethod</code>的构建也是使用builder模式,<code>new ServiceMethod.Builder(retrofit, method).build()</code>.其核心的内容就在这个<code>build()</code>方法之中.</p>
<p>在<code>build()</code>开始先是获取到一个<code>CallAdapter</code>,这个值怎么来的呢?其实是创建<code>Retrofit</code>时设置的<code>CallAdapter.Factory</code>进行创建的,规则是根据method的返回值和注解来查找构建具体的<code>CallAdapter</code>,具体的可以查看<code>Factory#get(...)</code>函数,例如<code>DefaultCallAdapterFactory#get(...)</code>只会判断method的返回类型是否为<code>Call</code>.基于同样的原理,有创建一个<code>Converter&lt;ResponseBody, T&gt;</code>用来将<code>OKHTTP</code>返回的<code>ResponseBody</code>转化为具体的类型<code>T</code>,在<code>build()</code>方法的后面部分,就是将method上的所用的注解都映射成为请求时的参数.其中method的每个参数都会对应到一个<code>ParameterHandler&lt;?&gt;</code>上,根据不同的注解,会用不同类型的<code>ParameterHandler&lt;?&gt;</code>,比如<code>Field</code>注解就对应上一个<code>ParameterHandler.Field&lt;?&gt;</code>,这样的目的就是后续对请求参数进行赋值的时候,各个<code>ParameterHandler&lt;?&gt;</code>只需要处理一种类型的数据格式.</p>
<h2 id="okhttpcall作用">OkHttpCall作用</h2>
<p><code>OkHttpCall</code>实现了<code>Call</code>接口,本质上这个<code>Call</code>和<code>okhttp3.Call</code>没有任何关系,但是他们的用法几乎一直,使用过<code>OKHTTP</code>的同学都知道,<code>Response response = client.newCall(request).execute();</code>,从<code>OkHttpClient#newCall(...)</code>得到的就是一个<code>okhttp3.Call</code>对象,通过这个对象我们可以执行同步或异步请求.既然是这样,那我们的<code>OkHttpCall</code>必定和<code>OkHttpClient</code>会有关联,果不其然,在<code>OkHttpCall</code>内部存在一个真正的<code>okhttp3.Call</code>,而这个<code>okhttp3.Call</code>代理了<code>OkHttpCall</code>的所用方法,那么这个<code>okhttp3.Call</code>是从哪里来的?</p>
<pre><code class="language-java">  private okhttp3.Call createRawCall() throws IOException {
    Request request = serviceMethod.toRequest(args);
    okhttp3.Call call = serviceMethod.callFactory.newCall(request); //构建retrofit时传入
    if (call == null) {
      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
    }
    return call;
  }
</code></pre>
<p>我们发现这里的逻辑就是我们直接使用<code>OKHTTP</code>时的获取<code>okhttp3.Call</code>的逻辑,第一行进行构建<code>Request</code>,因为开始我们的<code>serviceMethod</code>已经有了所用的请求的基本字段信息,就差每个请求的具体值,在这里就是把具体的值进行设置,而赋值的过程就是使用上文提及的<code>ParameterHandler&lt;?&gt;#apply(...)</code>方法,赋完值之后得到一个<code>Request</code>对象.从而获得一个可用的<code>Call</code>对象.</p>
<h2 id="数据解析">数据解析</h2>
<p>得到上文的<code>Call</code>后使用同步或异步的方式进行请求,<code>OkHttpCall</code>内部先接收到响应,对数据进行处理之后在抛给调用者,而这里的处理过程就是数据解析的过程.在<code>OkHttpCall#parseResponse()</code>中就是这个过程的处理,这里面使用了<code>ServiceMethod</code>构建时的<code>Converter&lt;ResponseBody, T&gt;</code>对象进行装换,也就是将<code>ResponseBody</code>转为具体的<code>T</code>类型,具体可以参考<code>GsonResponseBodyConverter</code></p>
<h1 id="尾声">尾声</h1>
<p>通过上面的说明,应该大体上了解了<code>Retrofit</code>的工作流程,当然很多时候我们会将他和<code>RxJava</code>结合在一起使用,我会在下一篇文章中说明一下.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeakCanary 原理分析]]></title>
        <id>https://kutear.github.io/post/2017-05-30-Android_Leakcanary</id>
        <link href="https://kutear.github.io/post/2017-05-30-Android_Leakcanary">
        </link>
        <updated>2017-05-30T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="reference-与-referencequeue">Reference 与 ReferenceQueue</h2>
<p>关于强软弱虚四种引用类型这里不会多说,但是多数时候我们都是最简单的使用这些类,很少涉及到其中的<code>ReferenceQueue</code> ,在所以引用的基类<code>Reference</code>中有一个构造函数<code>Reference(T referent, ReferenceQueue&lt;? super T&gt; queue)</code>,其中传入了一个<code>ReferenceQueue</code>,他的作用就是当被观察(使用引用的对象)的对象被JVM GC之后会将其加入到这个队列.</p>
<h2 id="leakcanary-分析">LeakCanary 分析</h2>
<p>通过上文的描述,当我们观察一个对象被回收之后,我们是可以知道的(通过读取<code>ReferenceQueue</code>中的值),放到Android上面来讲,内存泄露问题主要是发生在<code>Activity</code>上,当一个<code>Activity</code>被destory之后,就应该被回收,但是由于错误的引用,导致并不能被正常的回收.基于上面的描述,我们可以实现当<code>Activity</code>被destory之后,就开始观察他的回收,如果发生了GC,但是这个<code>Activity</code>依旧没有被回收,那么他就有可能发生了泄露.下面看看<code>LeakCanary</code>具体是怎么做的.</p>
<p>根据<code>LeakCanary</code>使用指南,我们知道入口函数</p>
<pre><code class="language-java">  public static RefWatcher install(Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
        .buildAndInstall();
  }
</code></pre>
<p>这里我们不细细分析具体过程,直接看看<code>buildAndInstall</code>函数.</p>
<pre><code class="language-java">  public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
      LeakCanary.enableDisplayLeakActivity(context);
      ActivityRefWatcher.install((Application) context, refWatcher);
    }
    return refWatcher;
  }
</code></pre>
<p>在<code>ActivityRefWatcher.install(...)</code>中最终调用了下面的代码</p>
<pre><code class="language-java">  public void watchActivities() {
    // Make sure you don't get installed twice.
    stopWatchingActivities();
    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
  }
</code></pre>
<p>也就是我们平时也会使用的<code>registerActivityLifecycleCallbacks</code>,在<code>lifecycleCallbacks</code>的<code>onActivityDestroyed(Activity activity)</code>中最终会调用<code>refWatcher.watch(activity);</code> ,其中<code>refWatcher</code>是<code>RefWatcher</code>的一个实例,<code>watch(activity)</code> 会调用他的重载函数</p>
<pre><code class="language-java">  public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
      return;
    }
    checkNotNull(watchedReference, &quot;watchedReference&quot;);
    checkNotNull(referenceName, &quot;referenceName&quot;);
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key);
    final KeyedWeakReference reference =
        new KeyedWeakReference(watchedReference, key, referenceName, queue); //WeakReference的子类  这里的queue就是上文多次提及的ReferenceQueue

    ensureGoneAsync(watchStartNanoTime, reference);
  }

  private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
    watchExecutor.execute(new Retryable() {
      @Override public Retryable.Result run() {
        return ensureGone(reference, watchStartNanoTime);
      }
    });
  }
</code></pre>
<p>可以看到最后调用<code>watchExecutor.execute(...)</code> 这里的<code>watchExecutor</code>是<code>AndroidWatchExecutor</code>,对应的函数为</p>
<pre><code class="language-java"> @Override public void execute(Retryable retryable) {
    //?? 为什么一定要在主线程执行??
    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
      waitForIdle(retryable, 0);
    } else {
      postWaitForIdle(retryable, 0);  //使用主线程的handler重新post到waitForIdle(...)上.
    }
  }
 
 void waitForIdle(final Retryable retryable, final int failedAttempts) {
    // This needs to be called from the main thread.
    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
      @Override public boolean queueIdle() {
        postToBackgroundWithDelay(retryable, failedAttempts);
        return false;
      }
    });
  }

  void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
    long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor);
    long delayMillis = initialDelayMillis * exponentialBackoffFactor;
    backgroundHandler.postDelayed(new Runnable() {
      @Override public void run() {
        Retryable.Result result = retryable.run(); //上文ensureGone(reference, watchStartNanoTime)的结果
        if (result == RETRY) {
          postWaitForIdle(retryable, failedAttempts + 1);
        }
      }
    }, delayMillis);
  }
</code></pre>
<p>所以最后的执行其实就是<code>ensureGone(reference, watchStartNanoTime)</code>这里,这就是具体的判断泄露的过程,</p>
<pre><code class="language-java">Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    long gcStartNanoTime = System.nanoTime();
    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);

    removeWeaklyReachableReferences();

    if (debuggerControl.isDebuggerAttached()) {
      // The debugger can create false leaks.
      return RETRY;
    }
    if (gone(reference)) {
      return DONE;
    }
    gcTrigger.runGc();   // 强制发生GC
  
    removeWeaklyReachableReferences();
  
  
  	//如果发生了GC该对象依旧没有被回收,那么就有可能发生了内存泄露
  	//就会到出heap进行分析
    if (!gone(reference)) {
      long startDumpHeap = System.nanoTime();
      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);

      File heapDumpFile = heapDumper.dumpHeap();
      if (heapDumpFile == RETRY_LATER) {
        // Could not dump the heap.
        return RETRY;
      }
      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
      heapdumpListener.analyze(
          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
              gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
  }

 private boolean gone(KeyedWeakReference reference) {
    return !retainedKeys.contains(reference.key);
  }

  private void removeWeaklyReachableReferences() {
    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
    // reachable. This is before finalization or garbage collection has actually happened.
    KeyedWeakReference ref;
    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
      retainedKeys.remove(ref.key);
    }
  }
</code></pre>
<p>好了,到此我们就知道了<code>LeakCanary</code>检测内存泄露的方法及过程,对于heap内存的导出并没分析,这确实也是比较重要的,在后续有空在弄一下.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抛开源码讲流程-Volley]]></title>
        <id>https://kutear.github.io/post/2017-04-21-Android_Volley</id>
        <link href="https://kutear.github.io/post/2017-04-21-Android_Volley">
        </link>
        <updated>2017-04-21T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本实现">基本实现</h2>
<p>创建单例RequestQueue来同一调度所有的Request,RequestQueue内部包含一个CacheQueue和一个NetworkQueue,分别存储缓存请求和网络请求序列。通过RequestQueue的add()函数向RequestQueue中添加请求。如果该请求应该被缓存那么就将他添加到CacheQueue，而CacheDispatcher(Thread)会处理CacheQueue中的请求事件，当这个请求在以前已经请求过，并且缓存的内容还没有过期，就会使用ResponseDelivery将缓存的结果通过Handler发送到主线程，如果缓存不存在或者已经过期就会将这个请求添加到NetworkQueue。如果该请求不允许被缓存，那么就会直接将这个请求添加到NetworkQueue，会有一个NetworkDispatcher(Thread，他的实例存在多个)来处理NetworkQueue中的请求事件，通过网络请求得到数据，如果是可以被缓存的请求，就先把返回的数据缓存后再利用ResponseDelivery将缓存的结果通过Handler发送到主线程。</p>
<h2 id="谈谈阻塞队列">谈谈阻塞队列</h2>
<p>上文中的RequestQueue和NetworkQueue的数据类型都是PriorityBlockingQueue，PriorityBlockingQueue 是一个支持优先级排序的无界阻塞队列。使用它的原因是因为Volley是支持并发的，NetworkQueue实例只有一个，但是却有多个NetworkDispatcher从中读取请求并执行请求，因此需要使用并发支持。</p>
<blockquote>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
</blockquote>
<p>在我们Volley框架中，显然以我们发送请求作为生产者，多个NetworkDispatcher(Thread)作为消费者。当队列中没有请求的时候，所有的NetworkDispatcher都会因为不能从队列中读到数据而进入阻塞状态。当队列中的请求数量达到队列的最大值时，我们发送请求的线程会进入阻塞，而发送请求的线程通常就是我们我的主线程，当然不允许阻塞，故选用队列要求是无界队列(容量不会满，主线程不会阻塞)</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法\处理方式</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th style="text-align:center">一直阻塞</th>
<th style="text-align:center">超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入方法</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">put(e)</td>
<td style="text-align:center">offer(e,time,unit)</td>
</tr>
<tr>
<td style="text-align:center">移除方法</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take()</td>
<td style="text-align:center">poll(time,unit)</td>
</tr>
<tr>
<td style="text-align:center">检查方法</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>
<p>在Volley的实现中，向队列添加Request就是通过put(e)进行的，而NetworkDispatcher从队列中获取Request就是通过take()进行的。</p>
<p>更多关于并发阻塞队列可以参考<a href="http://www.infoq.com/cn/articles/java-blocking-queue">infoQ</a></p>
<h2 id="网络请求部分">网络请求部分</h2>
<p>在没有特别指明的情况下，Volley在API&gt;=9时是使用HttpUrlConnect(封装为HurlStack),当API&lt;9时是使用HttpClient(封装为HttpClientStack)，并将HurlStack或HttpClientStack在封装到Network对象中去。上文提到网络请求最终会在NetworkDispatcher这个线程中执行，其执行的逻辑就是从队列中获取到Request，然后交给Network对象去做真正的请求，上文说过Network包含了HurlStack或HttpClientStack，对于不用的Android版本就分别委托不同的HttpStack去做请求，请求部分的代码平时大家都有写过，就跳过了。最终在NetworkDispatcher中拿到了请求回来的数据的封装NetworkResponse。</p>
<h2 id="数据解析">数据解析</h2>
<p>由于不同的请求会返回不同的数据类型，比如文件的二进制，普通的字符等等，所以把数据的解析委托给对应的Request，在NetworkDispatcher中拿到了NetworkResponse(content数据格式为字节数组)之后，通过Request#parseNetworkResponse(NetworkResponse)解析得到不同类型的Response&lt;?&gt;，比如Json就是将NetworkResponse持有的字节数组转化为对应的JsonBean。</p>
<h2 id="其他细节">其他细节</h2>
<p>重试机制，在每个Request中持有有个RetryPolicy，用于控制在什么情况下会进行重试，实现非常简单，就是在Network做网络请求时，如果遇到错误，但是RetryPolicy还满足条件，就会继续重新请求，直到不再满足RetryPolicy或者请求成功为止。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抛开源码讲流程-AsyncTask]]></title>
        <id>https://kutear.github.io/post/2017-04-20-Android_AsyncTask</id>
        <link href="https://kutear.github.io/post/2017-04-20-Android_AsyncTask">
        </link>
        <updated>2017-04-20T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本原理">基本原理</h2>
<p>其实AsyncTask的原理非常的简单，就是通过线程池执行一个异步任务并将异步任务的结果通过Handler抛到主线程。</p>
<h2 id="实现方式">实现方式</h2>
<p>在构造函数中创建了一个WorkerRunnable(并不是继承至Runnable而是Callable)对象和 一个FutureTask(继承至Runnable)对象，并且引用了WorkerRunnable对象。在执行AsyncTask#execute(...)时，其实就是先执行一个onPreExecute()函数，然后把我们的参数放进WorkerRunnable，并把FutureTask对象再封装到一个Runnable中放入一个待执行的队列(static)，如果当前没有任务在执行，就从队列中提取出这个FutureTask对应的Runnable，否则等待正在执行的任务执行完毕之后在提取下一个待执行任务(封装了FutureTask的Runnable)。到此，不管怎样，任务已经到队列中了，始终会轮到他执行。那怎么执行会干什么呢?上文说过使用Runnable封装的FutureTask其实也是一个Runnable,并且持有WorkerRunnable对象的引用。在FutureTask#run()中就是调用了WorkerRunnable#call()方法，而这个call()方法会调用doInBackground()函数并取得后台计算的结果，在call()的最后通过postResult()函数使用Handler发送消息到主线程，在主线程中执行了finish()，而finish()调用了我们很关心的onPostExecute()或onCancelled()(当调用了AsyncTask的cancel()方法的时候)方法，到此，三个重要的方法onPreExecute(),doInBackground(),onPostExecute()的调用逻辑就理清楚了。另外，有时在doInBackground()会使用publishProgress()来更新进度,publishProgress()内部也是使用Handler发送消息到主线程达到在主线程调用onProgressUpdate()的目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抛开源码讲流程-Handler]]></title>
        <id>https://kutear.github.io/post/2017-04-19-Android_Handler</id>
        <link href="https://kutear.github.io/post/2017-04-19-Android_Handler">
        </link>
        <updated>2017-04-19T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本原理">基本原理</h2>
<p>Handler在构造函数中会通过Looper.myLooper()获取到当前线程的Looper对象,以及获取到Looper的MessageQueue对象。当Handler发送一个消息的时候，其实就是向这个MessageQueue中存放一个Message对象，这个Message对象引用了Handler，在Looper的loop函数中，会从MessageQueue的next()函数中不断的获取Message对象，前面说过，Message含有Handler对象，这里对于Message的处理也是转交给Handler的diapatchMessage函数处理。对于一个Message的处理有三种方式，优先级从高到低依次是Message的calllBack,然后是Handler的callback，最后才是Handler的handlerMessage()方法。</p>
<h2 id="关于线程切换">关于线程切换</h2>
<p>对于线程的切换其实就是A线程(Looper所在线程)持有一个MessageQueue，B线程（Handler发送消息的线程）引用A线程中的MessageQueue对象，并向这个MessageQueue中插入Message对象，然后在A线程的Looper.loop()中取出这个Message对象，并对这个Message进行处理。所以对于消息的处理就由B线程切换到了A线程。</p>
<h2 id="单一线程looper唯一性">单一线程Looper唯一性</h2>
<p>在一个线程中只能存在Looper对象，Android主线程在ActivityThread的main函数中其实已经创建了,所以我们不能再在主线程进行Looper的创建。线程Looper唯一性的保证是ThreadLocal类实现。在Looper中含有ThreadLocal的静态字段，在创建Looper的之前会先检查是否当前线程已经存在Looper，存在的话会抛出异常。可以正常创建的话就创建对象，然后通过ThreadLocal使创建了的Looper对象绑定到当前线程的localValues中。后续获取当前线程的Looper对象是通过Looper.myLooper()，这个函数的实现就是通过ThreadLocal在当前线程中的localValues中取出Looper对象。</p>
<h2 id="message对象池">Message对象池</h2>
<p>官方推荐使用Message#obtain()来创建Message对象，原因就是Message存在一个对象池(static)，这个对象池的数据结构其实是Message为节点的一条链表。这个对象池的大小最大可为50。使用obtain()获取Message对象的时候是先从Message对象池中读取链表的头节点，并将读的对象相关标记位(正在使用)制空，如果链表节点数目为0，就只能创建新对象了。</p>
<h2 id="其他小细节">其他小细节</h2>
<p>MessageQueue的实现其实是通过链表来实现的，而链表的节点就是上文的Message对象。</p>
<p>Handler的removeCallbacks实现原理其实就是把MessageQueue链表中的某些节点移除掉。具体实现参见链表移除某个节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android知识点总结]]></title>
        <id>https://kutear.github.io/post/2017-04-17-Android_Advanced</id>
        <link href="https://kutear.github.io/post/2017-04-17-Android_Advanced">
        </link>
        <updated>2017-04-17T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android">Android</h1>
<ul>
<li>
<p>Server启动方式 || IntentService原理--&gt;只能startServive(...)启动 20s-&gt;ANR</p>
</li>
<li>
<p>broadcasts分类(无序广播,有序广播,Sticky广播) 10s-&gt;ANR  自定义权限  LocalBroadcastManager原理</p>
</li>
<li>
<p>Activity 启动模式 || 周期 ||Task<br>
以下是当 Activity A 启动 Activity B 时一系列操作的发生顺序：<br>
Activity A 的 onPause方法执行。<br>
Activity B 的 onCreate、onStart和 onResume方法依次执行。<br>
然后，如果 Activity A 在屏幕上不再可见，则其 onStop方法执行。</p>
</li>
<li>
<p>状态保存(Activity||自定义View) onSaveInstanceState调用时机(onStop之前 用户主动关闭不触发)   【Loader???】</p>
</li>
<li>
<p>Handler机制</p>
</li>
<li>
<p>AsyncTask原理(WorkerRunnable ||  FutureTask)</p>
</li>
<li>
<p>SharedPreference多进程共享</p>
</li>
</ul>
<h1 id="java">Java</h1>
<ul>
<li>
<p>内存模型</p>
<ul>
<li>
<p>程序计数器(线程私有)</p>
<blockquote>
<p>程序计数器PC，当前线程所执行的字节码行号指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。</p>
</blockquote>
</li>
<li>
<p>Java虚拟机栈(线程私有)</p>
<blockquote>
<p>虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)执行的同时都会创建一个栈帧结构，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。</p>
</blockquote>
</li>
<li>
<p>本地方法栈</p>
<blockquote>
<p>本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。</p>
</blockquote>
</li>
<li>
<p>Java堆</p>
<blockquote>
<p>Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。</p>
</blockquote>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
</li>
<li>
<p>方法区</p>
<blockquote>
<p>方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。</p>
</blockquote>
<ul>
<li>持久代</li>
<li>运行时常量池
<blockquote>
<p>运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">共享数据区</th>
<th style="text-align:center">线程私有区</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方法区(包括常量区)</td>
<td style="text-align:center">程序计数器</td>
</tr>
<tr>
<td style="text-align:center">Java堆[存放对象和数组]</td>
<td style="text-align:center">Java虚拟机栈</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">本地方法栈</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>线程同步问题</p>
<ul>
<li>synchronized</li>
<li>volatile</li>
<li>并发包</li>
</ul>
</li>
<li>
<p>GC</p>
<ul>
<li>判定方法(实施过程)
<ul>
<li>引用计数</li>
<li>引用链</li>
</ul>
</li>
<li>回收方法(各自特点)
<ul>
<li>标记清除</li>
<li>标记整理</li>
<li>复制</li>
</ul>
</li>
<li>内存分配方式
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
</li>
<li>分类
<ul>
<li>Minor GC</li>
<li>Major GC</li>
<li>Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React和ReactNative基础]]></title>
        <id>https://kutear.github.io/post/2017-04-17-React_React-Native_Base</id>
        <link href="https://kutear.github.io/post/2017-04-17-React_React-Native_Base">
        </link>
        <updated>2017-04-17T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>React-Router</p>
<pre><code class="language-javascript">&lt;Router&gt;
    &lt;Route path=&quot;/&quot; component={App}&gt;
      {/*http://host/*/}
      &lt;IndexRoute component={Dashboard} /&gt;
      {/*http://host/#//about*/}
      &lt;Route path=&quot;about&quot; component={About} /&gt;
      {/*http://host/#/inbox */}
      &lt;Route path=&quot;inbox&quot; component={Inbox}&gt;
        {/*http://host/#/inbox/message/id */}
        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;
        {/*http://host/#/messages/id */}
        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;
        {/*重定向*/}
        &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;
      &lt;/Route&gt;
    &lt;/Route&gt;
 &lt;/Router&gt;
</code></pre>
</li>
<li>
<p>Redux</p>
<ul>
<li>
<p>Action</p>
<p>是普通的对象，可以通过具体的函数(Action Creator)来返回</p>
</li>
<li>
<p>Reducer</p>
<p>通过Action返回state,在React中实际就是重置组件的state</p>
<p>多个reducer可以通过函数<code>combineReducer({reducer1,reducer2})</code>绑定。</p>
<pre><code class="language-javascript">const todoApp = combineReducers({
  todos,
  visibilityFilter
})
</code></pre>
</li>
<li>
<p>Store</p>
<pre><code class="language-javascript">const store = createStore(reducer)

//使用
render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
</li>
</ul>
</li>
<li>
<p>React-Redux</p>
<ul>
<li>
<p>函数<code>connect()</code>的使用。</p>
<pre><code class="language-javascript">const newComponent = connect(
  /*映射state到component的props*/
  stateToComponentsProps,
  /*component触发外部state变化的action*/
  mapDispatchToProps
)(Component)
</code></pre>
</li>
<li>
<p>Provider</p>
<pre><code class="language-javascript">&lt;Provider store={store}&gt;
    {Route}
&lt;/Provider&gt;
</code></pre>
</li>
<li>
<p>store</p>
<pre><code class="language-javascript">
</code></pre>
</li>
</ul>
</li>
<li>
<p>Navigator</p>
</li>
</ul>
<pre><code class="language-javascript">render(){
    let defaultName = 'FirstPageComponent';
    let defaultComponent = GFirst; //第一个显示的组件
    return(
          &lt;Navigator
              initialRoute = {{name:{defaultName},component:defaultComponent}}
              renderScene = {(router,navigator) =&gt; {
                  return &lt;router.component {...router.params} navigator={navigator}/&gt;
              }}
              configureScene={(router) =&gt; {
                  //页面启动动画
                  return Navigator.SceneConfigs.FloatFromBottom;
              }}
          /&gt;
      );
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android RecyclerView使用中的问题记录]]></title>
        <id>https://kutear.github.io/post/2017-04-13-Android_RecyclerView</id>
        <link href="https://kutear.github.io/post/2017-04-13-Android_RecyclerView">
        </link>
        <updated>2017-04-13T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="禁用recyclerview快速滑动之后默认的缓冲滑动效果">禁用RecyclerView快速滑动之后默认的缓冲滑动效果</h1>
<p>通过<code>google</code>一番，发现<code>RecyclerView</code>内部实现是使用了一个名为<code>ViewFlinger</code>的类，然而该类是<code>RecyclerView</code>的私有内部类，我们无法构建注入，所以就只能看看是在哪里进行了调用，通过代码搜索，找到函数</p>
<pre><code class="language-java">
	/**
     * Begin a standard fling with an initial velocity along each axis in pixels per second.
     * If the velocity given is below the system-defined minimum this method will return false
     * and no fling will occur.
     *
     * @param velocityX Initial horizontal velocity in pixels per second
     * @param velocityY Initial vertical velocity in pixels per second
     * @return true if the fling was started, false if the velocity was too low to fling or
     * LayoutManager does not support scrolling in the axis fling is issued.
     *
     * @see LayoutManager#canScrollVertically()
     * @see LayoutManager#canScrollHorizontally()
     */
    @Override
    public boolean fling(int velocityX, int velocityY) {
         ...
    }
</code></pre>
<p>根据注释部分的说明，传入x和y方向的速度，返回<code>true</code>表示开始猛滑，否则放弃猛滑。所以我们只要该函数一直返回<code>false</code>即可</p>
<h1 id="关于自定义layoutmanager">关于自定义LayoutManager</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Apk安装过程]]></title>
        <id>https://kutear.github.io/post/2017-02-15-Android_Apk_install</id>
        <link href="https://kutear.github.io/post/2017-02-15-Android_Apk_install">
        </link>
        <updated>2017-02-15T02:24:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="表皮">表皮</h1>
<p>系统默认的安装器<a href="https://android.googlesource.com/platform/packages/apps/PackageInstaller/+/marshmallow-release/src/com/android/packageinstaller/PackageInstallerActivity.java">com/android/packageinstaller/PackageInstallerActivity.java</a>。</p>
<p>点击安装会执行</p>
<pre><code class="language-java">    private void startInstall() {
        // Start subactivity to actually install the application
        Intent newIntent = new Intent();
        newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,
                mPkgInfo.applicationInfo);
        newIntent.setData(mPackageURI);
        newIntent.setClass(this, InstallAppProgress.class);
        newIntent.putExtra(InstallAppProgress.EXTRA_MANIFEST_DIGEST, mPkgDigest);
        newIntent.putExtra(
                InstallAppProgress.EXTRA_INSTALL_FLOW_ANALYTICS, mInstallFlowAnalytics);
        String installerPackageName = getIntent().getStringExtra(
                Intent.EXTRA_INSTALLER_PACKAGE_NAME);
        if (mOriginatingURI != null) {
            newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI);
        }
        if (mReferrerURI != null) {
            newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI);
        }
        if (mOriginatingUid != VerificationParams.NO_UID) {
            newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid);
        }
        if (installerPackageName != null) {
            newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME,
                    installerPackageName);
        }
        if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) {
            newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true);
            newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
        }
        if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI);
        startActivity(newIntent);
        finish();
    }
</code></pre>
<p>启动<code>InstallAppProgress.java</code>会执行</p>
<pre><code class="language-java">PackageManager pm = getPackageManager();
//originatingUid为发起安装的app的uid
//originatingURI,referrer也都是标识安装的发起者
VerificationParams verificationParams = new VerificationParams(null, originatingURI,
                referrer, originatingUid, manifestDigest);
pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,
                    installerPackageName, verificationParams, null);
</code></pre>
<p>上面代码我们大概过一下知道<code>mPackageURI</code>是APK的路径，<code>observer</code>是观察APK安装的一个观察者，<code>installFlag</code>设置安装标记，比如replace已有的APK,<code>installerPackageName</code>大概是发起安装的APK的的app的包名(待确认)。</p>
<h1 id="核心">核心</h1>
<p>下文基于android-sdk-23。</p>
<p>到此我们进入Android核心之一的<code>PackageManager</code>。介于之前对Android系统级<code>Manager</code>的了解，	<code>PackageManager</code>的子类<code>ApplicationPackageManager</code>其实引用的是一个<code>IPackageManager</code>,而<code>IPackageManager</code>的实现就是<code>PackageManagerService</code>(以下简称<code>PMS</code>)，在函数<code>installPackageWithVerificationAndEncryption()</code>中实际上调用了<code>PMS</code>的<code>installPackage(...)</code>函数。</p>
<pre><code class="language-java">installPackage(String originPath, IPackageInstallObserver2 observer,int installFlags, String installerPackageName,VerificationParams verificationParams,String packageAbiOverride)
</code></pre>
<p>这个函数的逻辑包括以下几部分逻辑</p>
<ol>
<li>
<p>检查当前使设备的人是否拥有安装apk的权限，检查调用安装apk的程序是否含有安装apk的权限。</p>
</li>
<li>
<p>使用<code>UserHandle</code>指示安装的apk归属于哪一个用户。</p>
</li>
<li>
<p>使用<code>Handler</code>发送一个<code>INIT_COPY</code>的消息。</p>
</li>
</ol>
<p><code>INIT_COPY</code>中把<code>InstallParams</code>(持有待安装app的信息)存入一个列表,然后在发送另外一个消息<code>MCS_BOUND</code>。在<code>MCS_BOUND</code>中会从上文中存放<code>InstallParams</code>的列表中依次取出待安装apk的部分信息。对于依次取出的<code>InstallParams</code>在执行函数<code>InstallParams#startCopy()</code>,在这个函数中会进行<code>media container service</code>绑定，如果多次(4次)尝试绑定都失败的话，就表示安装失败，退出，否则执行函数<code>InstallParams#handleStartCopy()</code>,<code>handleStartCopy()</code>方法很长,它的逻辑包含以下几点</p>
<ol>
<li>判断安装位置，根据<code>DefaultContainerServie#getMinimalPackageInfo()</code>获取推荐位置</li>
<li>判断/data/app空间是否足够，否则释放cache在尝试</li>
<li>如果启动了包验证的话，就会进入验证阶段</li>
<li>没有启动验证或验证通过进入<code>InstallArgs#copyApk(...)</code></li>
</ol>
<p>这里<code>copyApk(...)</code>的作用大致是</p>
<ol>
<li>
<p>首先mInstallerService.allocateStageDirLegacy申请足够的存储空间（data/app/vmdl</p>
<p>***.tmp目录）</p>
</li>
<li>
<p>得到申请的那部分空间的文件描述符，并且修改权限</p>
</li>
<li>
<p>IMediaContainerService#copyPackage 拷贝到指定目录，实现在DefaultContainerService中</p>
</li>
<li>
<p>NativeLibraryHelper#copyNativeBinariesWithOverride 拷贝二进制文件(so库)</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="http://kutear.qiniudn.com/2017/02/21/fc925c470b4d9785e69c8aebf1c387d9.png" alt=""></figure>
<p>到此app的所有文件拷贝到了<code>data/app/vmdl***.tmp</code>目录下。此时的目录结构大致如下</p>
<pre><code>data/app/vmdl***.tmp/
					/base.apk
					/split_***.apk  ???
					/lib
					   /lib***.so
</code></pre>
<p>在函数<code>InstallParams#handleStartCopy()</code>之后，是执行函数<code>InstallParams#handleReturnCode()</code> ，这个函数的逻辑主要包括一下几个要点：</p>
<ol>
<li>安装App之前的操作（<code>InstallArgs#doPreInstall(...)</code>）</li>
<li>安装App(<code>installPackageLI(...)</code>)</li>
<li>安装App之后的操作(<code>InstallArgs#doPostInstall(res.returnCode, res.uid);</code>)</li>
<li>备份操作</li>
</ol>
<p>安装之前主要是处理清理工作，删除一些文件目录。</p>
<p>// TODO</p>
<h1 id="参考">参考</h1>
<ul>
<li>
<p><a href="http://blog.csdn.net/singwhatiwanna/article/details/19578947">Android内核解读-应用的安装过程</a></p>
</li>
<li>
<p><a href="https://guolei1130.github.io/2017/01/04/Android%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E7%9A%84/">Android应用程序是如何安装的</a></p>
</li>
<li>
<p><a href="http://www.ieveryday.pub/index.php/Andriod_Framework_Work_Note_Url_6">使用PackageInstaller安装app流程学习小结</a></p>
<p>​</p>
</li>
</ul>
]]></content>
    </entry>
</feed>